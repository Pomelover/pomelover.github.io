<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第十五章：面向对象程序设计 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向对象程序设计 简介​	面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。 ​	继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其它类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，可以在一定程度忽略掉他们的区别。  OOP概述​	面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相">
<meta property="og:type" content="article">
<meta property="og:title" content="第十五章：面向对象程序设计">
<meta property="og:url" content="https://pomelover.github.io/2025/12/30/CppPrimer/CppPrimer-14/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="面向对象程序设计 简介​	面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。 ​	继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其它类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，可以在一定程度忽略掉他们的区别。  OOP概述​	面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/cpp_logo.png">
<meta property="article:published_time" content="2025-12-30T13:54:00.507Z">
<meta property="article:modified_time" content="2026-01-03T11:19:04.060Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ Primer">
<meta property="article:tag" content="C++ 学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/cpp_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第十五章：面向对象程序设计",
  "url": "https://pomelover.github.io/2025/12/30/CppPrimer/CppPrimer-14/",
  "image": "https://pomelover.github.io/images/cpp_logo.png",
  "datePublished": "2025-12-30T13:54:00.507Z",
  "dateModified": "2026-01-03T11:19:04.060Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/30/CppPrimer/CppPrimer-14/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第十五章：面向对象程序设计',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">第十五章：面向对象程序设计</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">第十五章：面向对象程序设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-03T11:19:04.060Z" title="更新于 2026-01-03 19:19:04">2026-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="面向对象程序设计-简介"><a href="#面向对象程序设计-简介" class="headerlink" title="面向对象程序设计 简介"></a>面向对象程序设计 简介</h1><p>​	面向对象程序设计基于三个基本概念：<strong>数据抽象、继承和动态绑定。</strong></p>
<p>​	继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其它类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，可以在一定程度忽略掉他们的区别。</p>
<hr>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a><code>OOP</code></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​	<strong>面向对象程序设计</strong>的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​	<strong>通过继承联系在一起的类构成一种层次关系，通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称作派生类。</strong>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>​	在<code>C++</code>语言中，<strong>基类将类型相关的函数与派生类不做改变直接继承的函数区分对待</strong>。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明为虚函数。</p>
<p>​	派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的。类派生列表的形式是：<strong>首先是一个冒号，后面紧跟以逗号分割的积累列表，其中每个基类前面可以有访问说明符。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(size_n)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>: <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<code>public Quote</code>意味着我们能够将<code>Bulk_quote</code>的对象当作<code>Quote</code>的对象来使用。</p>
<p>​	派生类必须在其内部对所有重新定义的虚函数进行声明，派生类可以在这样的函数之前加上<code>virtual</code>关键字。<code>C++</code>新标准允许派生类显式注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个<code>override</code>关键字。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>​	通过动态绑定，我们能够用同一段代码分别处理<code>Queto</code>和<code>Bulk_quote</code>的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream&amp; os,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Quote&amp; item, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据传入 item 形参的对象类型调用 Quote::net_price</span></span><br><span class="line">    <span class="comment">// 或者 Bulk_quote::net_price</span></span><br><span class="line">    <span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line"></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="built_in">isbn</span>()    <span class="comment">// 调用 Quote::isbn</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot; # sold: &quot;</span> &lt;&lt; n</span><br><span class="line">       &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	因为，函数的运行版本由实参决定，即在运行时选择函数的版本，因此动态绑定有时也称为运行时绑定。</p>
<blockquote>
<p>在<code>C++</code>语言中，当我们使用<strong>基类的引用或指针调用虚函数时，将发生动态绑定</strong>。</p>
</blockquote>
<hr>
<h1 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h1><p>​	定义基类和派生类的方式在很多方面上与我们已知的定义其它类的方式类似，但是也有不同。</p>
<h2 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Quote</span>(<span class="type">const</span> string&amp; book, <span class="type">double</span> sales_price):</span><br><span class="line">        <span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(sales_price) &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>作为继承关系中根节点的类通常都会定义一个虚析构函数</strong>。</p>
<h3 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h3><p>​	派生类可以继承其基类的成员，然而当遇到<code>net_price</code>这样与类型相关的操作时，派生类必须对其重新定义。派生类需要对这些操作提供自己的新定义以覆盖从基类继承而来的旧定义。</p>
<p>​	<code>C++</code>语言中，基类必须将两种成员函数区分开来：<strong>一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。</strong>对于前者，基类通常将其定义为<strong>虚函数</strong>。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p>​	<strong>任何构造函数之外的非静态函数都可以是虚函数</strong>。关键字<code>virtual</code>只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>​	成员函数如果没被声明为虚函数，<strong>则其解析过程发生在编译时而非运行时</strong>。</p>
<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>​	派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。在某些时候，基类希望它的派生类访问某些成员，同时禁止其它成员访问，这时候我们使用<code>protected</code>访问运算符说明这样的成员。</p>
<h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><p>​	派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来。派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote &#123;     <span class="comment">// Bulk_quote 继承自 Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp;, <span class="type">double</span>, std::<span class="type">size_t</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类的函数版本以实现大量购买的折扣策略</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> min_qty = <span class="number">0</span>;    <span class="comment">// 适用折扣策略的最低购买量</span></span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;      <span class="comment">// 以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。此外，<strong>我们能将公有派生类型的对象绑定到基类的引用或指针上</strong>。大多数类都只继承自一个类，这种形式的继承被称作单继承。</p>
<h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>​	派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其它的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>​	派生类可以在它覆盖的函数前使用<code>virtual</code>关键字，但不是必须这么做。<code>C++</code>允许派生类显式注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在其它修饰词后加<code>override</code>。</p>
<h3 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h3><p>​	一个派生类对象包含多个组成部分：一个含有派生类自己定义的非静态成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
<p>​	<code>C++</code>标准中并没有规定派生类对象在内存中如何分布，但是我们可以认为<code>Bulk_quote</code>对象包含如下的两部分：</p>
<p><img src="/Bulk_quote_memory.png" alt="image-20251230225932541"></p>
<p>​	因为派生类对象中含有与其基类对应的组成部分，所以我们能把派生类对象当作基类使用，而且我们能将基类的指针或引用绑定到派生类对象中的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;        <span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk;   <span class="comment">// 派生类对象</span></span><br><span class="line">Quote *p = &amp;item;  <span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;         <span class="comment">// p指向Bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;   <span class="comment">// r绑定到bulk的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>这种转换通常称为派生类向基类的类型转换</strong>。和其它类型转换一样，编译器会隐式执行派生类到基类的转换。这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方，指针同样。</p>
<blockquote>
<p>派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</p>
</blockquote>
<h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><p>​	尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，和其它创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<blockquote>
<p><strong>每个类控制自己的成员初始化过程</strong>。</p>
</blockquote>
<p>​	<strong>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p,</span><br><span class="line">           std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">    : <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 与之前一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p>
<blockquote>
<p>首先初始化基类部分，然后按照声明顺序依次初始化派生类成员。</p>
</blockquote>
<h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><p>​	<strong>派生类可以访问基类的公有成员和受保护成员</strong>。</p>
<blockquote>
<p>遵循基类的接口：</p>
<p>​	必须明确一点：<strong>每个类负责定义各自的接口</strong>。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。因此，派生类对象不能直接初始化基类成员，尽管从语法上来说，我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值。派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
</blockquote>
<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>​	如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员都只存在唯一的实例。静态成员遵循同样的访问控制规则。</p>
<h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><p>​	派生类的声明与其他类差别不大，<strong>声明中包含类名但是不包含它的派生列表</strong>。一个声明语句的目的是令程序知晓某个名字的存在，以及该名字表示什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义的其它细节必须与类的主体一起出现。</p>
<h3 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h3><p>​	如果我们想将某个类用作基类，<strong>则该类必须已经定义而非仅仅被声明</strong>。这个规定也隐含了一个类不能派生它本身的含义。</p>
<p>​	一个类是基类的同时也可以是一个派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	在这个继承关系中，<code>Base</code>是<code>D1</code>的直接基类，是<code>D2</code>的间接基类。每个类都会继承直接基类的所有成员。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<h3 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h3><p>​	有时候我们希望一个类不被继承，或者不想考虑它是否适合作为一个基类。为了实现这一目的，<code>C++11</code>提供了一种防止继承发生的方法，在类名后加一个关键字<code>final</code>。</p>
<h2 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h2><blockquote>
<p>理解基类和派生类之间的类型转换是理解<code>C++</code>语言面向对象编程的关键所在。</p>
</blockquote>
<p>​	通常情况下，我们想把引用或指针绑定到一个对象上，<strong>则引用或指针应与对象的类型一致</strong>，或者对象的类型含有一个可接受的<code>const</code>类型转换规则。</p>
<p>​	但是，存在继承关系的类是一个重要的例外：<strong>我们可以将基类的指针或引用绑定到派生类对象上</strong>。可以将基类的引用或指针绑定到派生类对象上有一层极为重要的含义：当使用基类引用（或指针）时，实际上我们并不清楚该引用（或指针所绑定对象的真实类型）。该对象可能是基类的对象，也可能是派生类的对象。</p>
<blockquote>
<p>和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
</blockquote>
<h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>​	当我们使用存在继承关系的类时，必须将一个变量或其它表达式的静态类型与该表达式表示对象的动态类型区分开来。<strong>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。</strong>动态类型直到运行时才是可知的。</p>
<p>​	如果表达式既不是引用也不是指针，<strong>则它的动态类型永远与静态类型一致</strong>。</p>
<blockquote>
<p>基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。</p>
</blockquote>
<h3 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h3><p>​	之所以存在派生类向基类的类型转换，是因为派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该积累部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。</p>
<p>​	<strong>因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换。</strong></p>
<p>​	编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为<strong>编译器只能通过检查指针或引用的静态类型来判断该转换是否合法</strong>。如果在基类中含有一个或多个虚函数，我们可以使用<code>dynamic_cast</code>请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用<code>static_cast</code>来强制覆盖掉编译器的检查工作。</p>
<h3 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h3><p>​	派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>
<p>​	当我们初始化或赋值一个类类型的对象时，我们实际上是在调用某个函数。当执行初始化时，我们调用构造函数；在执行赋值操作时，我们调用赋值运算符。<strong>这些成员通常都包含一个参数，该参数的类型是类类型的<code>const</code>版本的引用。</strong></p>
<p>​	因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝&#x2F;移动操作传递一个派生类的对象。这些操作不是虚函数。<strong>当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。</strong>赋值运算符也类似。</p>
<blockquote>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p>关键概念：<strong>存在继承关系的类型之间的转换规则</strong></p>
<p>​	要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：</p>
<ul>
<li><p>从派生类向基类的类型转换只能对指针或引用类型有效；</p>
</li>
<li><p>基类向派生类不存在隐式类型转换；</p>
</li>
<li><p>和其它成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</p>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然定义了拷贝控制成员，因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。需要注意的是，这种操作只处理派生类对象的基类部分。</p>
</li>
</ul>
</blockquote>
<hr>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>​	当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为，我们只有知道运行时才能知道到底调用哪个版本的虚函数，所以所有虚函数都必须有定义。<strong>我们必须为每一个虚函数都提供定义，不管它是否被用到了。</strong></p>
<h2 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h2><p>​	<strong>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象类型相匹配的一个。</strong>必须要明确：<strong>动态绑定只有当我们通过指针或引用时才会发生。</strong>当我们通过一个具有普通类型的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p>
<blockquote>
<p>关键概念：**<code>C++</code>中的多态性**</p>
<p>​	<code>OOP</code>的核心思想是多态性。多态性这个词源自希腊语，其含义是多种形式。我们把具有继承类型的多个类型称为多态类型，因为我们能使用这些类型的多种形式而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型的不同是<code>C++</code>语言支持多态性的根本所在。</strong></p>
<p>​	当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本。判断的依据是引用或指针所绑定的对象的真是类型。</p>
<p>​	另一方面，对非虚函数的调用在编译时进行绑定。类似的，<strong>通过对象进行的函数调用也在编译时绑定</strong>。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型和静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本。</p>
</blockquote>
<h2 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><p>​	当我们在派生类中覆盖某个虚函数时，可以再一次使用<code>virtual</code>关键字指出该函数的性质。但是这并不是必须的，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p>
<p>​	一个派生类的函数如果覆盖了某个继承中的虚函数，<strong>则它的形参类型必须与被它覆盖的基类函数完全一致</strong>。返回类型同样也需要与基类函数匹配。但，该规则有一个例外：<strong>当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</strong>也就是说：如果<code>D</code>由<code>B</code>派生得到，则基类的虚函数可以返回<code>B*</code>而派生类的对应函数可以返回<code>D*</code>，只不过这样的返回类型要求从<code>D</code>到<code>B</code>的类型转换是可访问的。</p>
<blockquote>
<p>基类中的虚函数在派生类中隐含地也是一个虚函数。<strong>当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</strong></p>
</blockquote>
<h2 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a><code>final</code>和<code>override</code>说明符</h2><p>​	派生类如果定义了一个函数与基类中虚函数的名字相同但形参列表不同，这仍然是合法行为。<strong>编译器将认为这个新定义的这个函数与基类中原有的函数是相互独立的</strong>。这时，派生类的函数并没有覆盖掉基类的版本。这种声明往往意味着发生了错误。</p>
<p>​	要想调试并发现这一的错误显然非常困难。在<code>C++</code>新标准中我们可以使用<code>override</code>来说明派生类中的虚函数。这么做的好处是让我们函数意图更清楚的同时让编译器为我们发现一些错误。</p>
<p>​	我们还能把某个函数指定为<code>final</code>，如果我们已经把函数定义成<code>final</code>了，则<strong>之后任何尝试覆盖该函数的操作都将引发错误</strong>。<code>final</code>和<code>override</code>说明符出现在参数列表以及以及尾置返回类型之后。</p>
<h2 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h2><p>​	虚函数也可以有默认实参，如果某次函数调用使用了默认实参，<strong>则该实参由本次调用的静态类型决定</strong>。换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<blockquote>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
<h2 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h2><p>​	某些情况下，我们希望对虚函数的调用不要进行动态绑定，此时我们可以利用作用域运算符实现这一目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseQ-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>​	该代码强行调用<code>Quote</code>的<code>net_price</code>函数，而不管<code>baseQ</code>实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<p>​	什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。</p>
<blockquote>
<p><strong>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时调用将被解析为对派生类版本自身的调用，从而导致无限递归。</strong></p>
</blockquote>
<hr>
<h1 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h1><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>​	有时候继承关系中会存在函数在基类中并没有实际意义，我们不希望用户对其进行调用，我们可以使用纯虚函数实现这个目的。和虚函数不同的是，一个纯虚函数无需定义，我们通过在函数体的位置书写<code>=0</code>就可以将一个虚函数声明为纯虚函数。<code>=0</code>只能出现在类内部的虚函数声明语句中。我们也可以为纯虚函数提供定义，不过函数体必须定义在类外部，我们不能在类的内部为一个<code>=0</code>的函数提供函数体。</p>
<h2 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h2><p>​	含有（<strong>或者未经覆盖直接继承</strong>）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类也可以覆盖该接口。<strong>我们不能直接创建一个抽象基类的对象</strong>。</p>
<h2 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h2><p>​	派生类构造函数必须先初始化它的直接基类，而且基类的初始化发生在派生类自身之前。</p>
<blockquote>
<p>关键概念：重构</p>
<p>​	重构负责重新设计类的体系以便将操作和&#x2F;或数据从一个类移动到另一个类中。</p>
</blockquote>
<hr>
<h1 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h1><p>​	每个类分别控制着其成员对于派生类来说是否可访问。</p>
<h2 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h2><p>​	一个类使用<code>protected</code>关键字来声明那些它希望与派生类分享但是不想被其它公共访问使用的成员。</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的；</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的；</li>
<li>派生类中的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员和友元来说是可访问的；</li>
</ul>
<p>​	为了理解最后一条规则，考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;        <span class="comment">// protected 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">// 能访问 Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    <span class="comment">// 不能访问 Base::prot_mem</span></span><br><span class="line">    <span class="type">int</span> j;                          <span class="comment">// 默认是 private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp; s)</span> </span>&#123;</span><br><span class="line">    s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：clobber 不能访问 Base 的 protected 成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	派生类的成员和友元只能访问派生类对象中基类部分受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限。</p>
<h2 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h2><p>​	某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</p>
<p>​	<strong>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。</strong>对基类成员的访问权限<strong>只与基类中的访问说明符有关</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;      <span class="comment">// public 成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;        <span class="comment">// protected 成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> priv_mem;       <span class="comment">// private 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pub_Derv</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// 正确：派生类能访问 protected 成员</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：private 成员对派生类来说是不可访问的</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Priv_Derv</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="comment">// private 不影响派生类的访问权限</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	派生访问说明符的目的是控制派生类用户对于基类成员的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;     <span class="comment">// 继承自 Base 的成员是 public 的</span></span><br><span class="line">Priv_Derv d2;    <span class="comment">// 继承自 Base 的成员是 private 的</span></span><br><span class="line"></span><br><span class="line">d<span class="number">1.</span><span class="built_in">pub_mem</span>();    <span class="comment">// 正确：pub_mem 在派生类中是 public 的</span></span><br><span class="line">d<span class="number">2.</span><span class="built_in">pub_mem</span>();    <span class="comment">// 错误：pub_mem 在派生类中是 private 的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	如果继承是公有的，则成员将遵循原有的访问说明符。在<code>Priv_Derv</code>中，<code>Base</code>的成员是私有的，因此类的用户不能调用<code>pub_mem</code>。派生访问说明符还可以控制继承自派生类的新类的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Public</span> : <span class="keyword">public</span> Pub_Derv &#123;</span><br><span class="line">    <span class="comment">// 正确：Base::prot_mem 在 Pub_Derv 中仍然是 protected 的</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Private</span> : <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">    <span class="comment">// 错误：Base::prot_mem 在 Priv_Derv 中是 private 的</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	如果我们采用受保护继承，则<code>Base</code>的所有公有成员在新定义的类中都是受保护的。</p>
<h2 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h2><p>​	派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定<code>D</code>继承自<code>B</code>:</p>
<ul>
<li>只有当<code>D</code>公有地继承<code>B</code>时，<strong>用户代码才能使用派生类向基类的转换</strong>；如果<code>D</code>继承<code>B</code>的方式是受保护的或者私有的，则用户代码不能使用该转换；</li>
<li>不论<code>D</code>以什么方式继承<code>B</code>，**<code>D</code>的成员函数和友元都能使用派生类向基类的转换**，派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的；</li>
<li>如果<code>D</code>继承<code>B</code>的方式是公有的或者受保护的，则<code>D</code>的派生类的成员和友元能够使用<code>D</code>向<code>B</code>的类型转换；反之，如果<code>D</code>继承<code>B</code>的方式是私有的，则不能使用；</li>
</ul>
<blockquote>
<p>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的，反之则不行。</p>
<hr>
<p>关键概念：<strong>类的设计与受保护的成员</strong></p>
<p>​	不考虑继承，我们可以认为类有两种用户：普通用户和类的实现者。普通用户使用类的对象，只能访问类的公有成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的共有部分，也能访问私有部分。</p>
<p>​	如果进一步考虑继承的话就会出现第三种用户，即派生类。<strong>基类把它希望派生类能够使用的部分声明成受保护的。</strong>普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>​	<strong>和其他类一样，基类应该将其接口成员声明为公有的；</strong>同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>
</blockquote>
<h2 id="友元和继承"><a href="#友元和继承" class="headerlink" title="友元和继承"></a>友元和继承</h2><p>​	友元关系不能传递，同样也不能继承。基类的友元在访问派生类时不具有特殊性，派生类的友元也不能随意访问基类的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 friend 声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;    <span class="comment">// Pal 在访问 Base 的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> b.prot_mem; </span><br><span class="line">    &#125;   <span class="comment">// 正确：Pal 是 Base 的友元</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> s.j; </span><br><span class="line">    &#125;   <span class="comment">// 错误：Pal 不是 Sneaky 的友元</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> s.prot_mem; </span><br><span class="line">    &#125;   <span class="comment">// 正确：Pal 是 Base 的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	每个类负责控制自己的成员访问权限。当一个类将另一个类声明为友元，则这种友元关系只对作出声明的类有效。</p>
<h2 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h2><p>​	有时我们可以通过<code>using</code>声明来改变派生类继承的某个名字的访问级别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;   <span class="comment">// 注意：private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保持对象尺寸大小相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>派生类只能为那些它可以访问的名字提供<code>using</code>声明。</p>
</blockquote>
<h2 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h2><p>​	默认派生运算符也由定义派生类所用的关键字来决定。默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；而使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
<hr>
<h1 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h1><p>​	每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，<strong>派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的定义。</strong></p>
<h2 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h2><p>​	一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型可能不一致，<strong>但是我们能使用哪些成员仍然由静态类型决定</strong>。</p>
<h2 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h2><p>​	和其它定义域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将隐藏外层作用域中的名字。</p>
<blockquote>
<p>派生类的成员将隐藏同名的基类成员。</p>
</blockquote>
<h2 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h2><p>​	我们可以用作用域运算符来使用隐藏的成员。作用域运算符将覆盖掉原有的查找规则。</p>
<blockquote>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其它定义在基类中的名字。</p>
<hr>
<p>关键概念：<strong>名字查找与继承</strong></p>
<p>​	理解函数调用的解析过程对于理解 <code>C++</code> 的继承至关重要。假定我们调用 <code>p-&gt;mem()</code> 或者 <code>obj.mem()</code>，则依次执行以下 4 个步骤：</p>
<ul>
<li><p>首先确定 <code>p</code>（或 <code>obj</code>）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。</p>
</li>
<li><p>在 <code>p</code>（或 <code>obj</code>）的静态类型对应的类中查找 <code>mem</code>。如果找不到，则依次在直接基类中查找直到继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。</p>
</li>
<li><p>一旦找到了 <code>mem</code>，就进行常规的类型检查以确认对于当前找到的 <code>mem</code>，本次调用是否合法。</p>
</li>
<li><p>假设调用合法，则编译器将根据调用的是成员函数而产生不同的代码：</p>
<ul>
<li>如果 <code>mem</code> 是虚函数且我们是通过引用或者指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果 <code>mem</code> 不是虚函数或者我们是通过对象（而非引用或者指针）进行的调用，则编译器将产生一个常规函数调用。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="一如往常，名字查找先于类型检查"><a href="#一如往常，名字查找先于类型检查" class="headerlink" title="一如往常，名字查找先于类型检查"></a>一如往常，名字查找先于类型检查</h2><p>​	定义在派生类中的函数也不会重载其基类的成员，和其它作用域一样，如果派生类的成员与基类的某个成员同名，则派生类将会在其作用域内隐藏该基类成员。</p>
<h2 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h2><p>​	因此，基类与派生类中的虚函数必须有相同形参列表，假如不同形参列表，则会发生隐藏。</p>
<h2 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h2><p>​	派生类可以覆盖重载函数的0个或多个实例，如果派生类希望所有重载版本对于它来说都是可见的，那么它就需要覆盖所有版本或者一个都不覆盖。</p>
<p>​	如果你只需要覆盖一些而非全部函数，则好的解决方案是用<code>using</code>声明语句，这样就无需覆盖每一个重载版本了。</p>
<hr>
<h1 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h1><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>​	继承关系对基类拷贝控制最直接的影响是基类通常定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。当我们<code>delete</code>一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，<strong>则有可能出现指针的静态类型与被删除的动态类型不符的情况</strong>。</p>
<p>​	为了确保我们执行的是正确版本的析构函数，我们通过将基类的析构函数声明为虚析构函数来解决。<strong>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</strong></p>
<h3 id="虚析构函数将阻止合成移动操作"><a href="#虚析构函数将阻止合成移动操作" class="headerlink" title="虚析构函数将阻止合成移动操作"></a>虚析构函数将阻止合成移动操作</h3><p>​	如果一个类定义了析构函数，即使它通过<code>=defualt</code>的形式使用了合成版本，编译器也不会为这个类合成移动操作。</p>
<h2 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h2><p>​	基类或派生类的合成拷贝控制成员行为与其它合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁操作。</p>
<h3 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h3><p>​	基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式可能导致有的派生类成员成为被删除的函数：</p>
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数被删除或者不可访问，则派生类中对应的成员将是被删除的；</li>
<li>如果在基类中有一个不可访问或删除掉的西沟用函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分；</li>
<li>编译器将不会合成一个删除掉的移动操作。</li>
</ul>
<h3 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h3><p>​	大多数基类都会定义一个虚析构函数，因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<h2 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h2><p>​	派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类的基类部分。因此派生类的拷贝和移动构造在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。<strong>但析构函数只负责销毁派生类自己分配的资源。</strong></p>
<h3 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h3><p>​	当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象基类部分。</p>
<blockquote>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝（或移动）构造函数。</p>
</blockquote>
<h3 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h3><p>​	与拷贝和移动构造函数一样，派生类的赋值运算符也必须为其基类部分赋值。</p>
<h3 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h3><p>​	派生类析构函数只负责销毁由派生类自己分配的资源，对象销毁的顺序正好与其创建的顺序相反，派生类析构函数首先执行，然后是基类的析构函数。</p>
<h3 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h3><p>​	在派生类对象的构造过程中，<strong>基类部分会先被构造，而派生类部分此时尚未初始化</strong>；在析构过程中顺序相反，<strong>当执行基类析构函数时，派生类部分已经被销毁</strong>。因此，无论是在基类构造函数还是基类析构函数执行期间，整个对象都处于一种“未完成”的状态。为了保证程序的安全性，编译器规定：<strong>在构造或析构阶段，对象的动态类型被视为当前正在构造或析构的类本身</strong>，虚函数调用也只会绑定到该类中定义的版本，而不会分派到派生类中。</p>
<blockquote>
<p> <strong>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</strong></p>
</blockquote>
<h2 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h2><p>​	在<code>C++11</code>新标准中，派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>​	派生类继承基类构造函数的方式是提供一条注明了基类名的<code>using</code>声明语句。通常情况下，<code>using</code>声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，<code>using</code>声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。</p>
<h3 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h3><p>​	和普通成员的<code>using</code>声明不一样，一个构造函数的<code>using</code>声明不会改变该构造函数的访问级别。一个<code>using</code>声明语句不能指定<code>explicit</code>或<code>constexpr</code>。如果基类的构造函数是<code>explicit</code>&#x2F;<code>constexpr</code>，则继承的构造函数也拥有相同的属性。</p>
<p>​	当基类的构造函数带有默认实参时，这些默认实参<strong>不会被派生类继承</strong>。派生类会获得多个“继承而来的构造函数”，每一个都相当于在参数列表中<strong>去掉了一个默认实参的形式</strong>。例如，若基类构造函数的第二个参数具有默认值，派生类将得到两个构造函数：一个接收完整参数列表，另一个只接收去掉默认参数后的参数列表。</p>
<p>​	如果基类含有多个构造函数，派生类在大多数情况下会继承它们。但存在两个重要例外：第一，若派生类自己定义了一个与基类构造函数<strong>参数列表完全相同</strong>的构造函数，则该构造函数不会被继承，派生类中定义的版本将覆盖继承而来的构造函数；第二，<strong>默认构造函数、拷贝构造函数和移动构造函数不会被继承</strong>，它们始终按照语言规则在派生类中合成或删除。因此，当一个类只继承了构造函数而未显式定义默认构造函数时，若继承的构造函数都需要参数，编译器仍会为派生类合成一个默认构造函数（前提是规则允许）。</p>
<hr>
<h1 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	当我们使用继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。</p>
<h3 id="在容器中放置指针而非对象"><a href="#在容器中放置指针而非对象" class="headerlink" title="在容器中放置指针而非对象"></a>在容器中放置指针而非对象</h3><p>​	当我们希望在容器中存放具有继承关系的对象中，我们实际上存放的通常是基类的指针。</p>
<h2 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写<code>Basket</code>类</h2><p>​	对于<code>C++</code>面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以我们通常定义一些辅助类来处理这种复杂情况。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/30/CppPrimer/CppPrimer-14/">https://pomelover.github.io/2025/12/30/CppPrimer/CppPrimer-14/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++ Primer</a><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width no-desc" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第十四章：重载运算与类型转换</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/05/CppPrimer/CppPrimer-02/" title="第三章：字符串、向量和数组"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-05</div><div class="info-item-2">第三章：字符串、向量和数组</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/08/CppPrimer/CppPrimer-05/" title="第六章：函数"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-08</div><div class="info-item-2">第六章：函数</div></div></div></a><a class="pagination-related no-desc" href="/2025/11/25/CppPrimer/CppPrimer-01/" title="第二章：变量和基本类型"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-25</div><div class="info-item-2">第二章：变量和基本类型</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/07/CppPrimer/CppPrimer-03/" title="第四章：表达式"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-07</div><div class="info-item-2">第四章：表达式</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/12/CppPrimer/CppPrimer-06/" title="第七章：类"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">第七章：类</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/07/CppPrimer/CppPrimer-04/" title="第五章：语句"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-07</div><div class="info-item-2">第五章：语句</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">面向对象程序设计 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OOP"><span class="toc-number">2.</span> <span class="toc-text">OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">动态绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">定义基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.1.</span> <span class="toc-text">成员函数与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.2.</span> <span class="toc-text">访问控制与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">定义派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">派生类中的虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.</span> <span class="toc-text">派生类对象及派生类向基类的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">派生类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">3.2.4.</span> <span class="toc-text">派生类使用基类的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">3.2.5.</span> <span class="toc-text">继承与静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">3.2.6.</span> <span class="toc-text">派生类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB"><span class="toc-number">3.2.7.</span> <span class="toc-text">被用作基类的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-number">3.2.8.</span> <span class="toc-text">防止继承的发生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">类型转换与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">静态类型与动态类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%BB%8E%E5%9F%BA%E7%B1%BB%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.2.</span> <span class="toc-text">不存在从基类向派生类的隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">在对象之间不存在类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%AF%E8%83%BD%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E8%A2%AB%E8%A7%A3%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">对虚函数的调用可能在运行时才被解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0-1"><span class="toc-number">4.2.</span> <span class="toc-text">派生类中的虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%92%8Coverride%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">final和override说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">4.4.</span> <span class="toc-text">虚函数与默认实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%81%BF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">回避虚函数的机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">抽象基类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E6%98%AF%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">含有纯虚函数的类是抽象基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%83%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">派生类构造函数只初始化它的直接基类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF-1"><span class="toc-number">6.</span> <span class="toc-text">访问控制与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">6.1.</span> <span class="toc-text">受保护的成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E3%80%81%E7%A7%81%E6%9C%89%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">公有、私有和受保护继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">派生类向基类转换的可访问性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">6.4.</span> <span class="toc-text">友元和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E4%B8%AA%E5%88%AB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text">改变个别成员的可访问性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BF%9D%E6%8A%A4%E7%BA%A7%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">默认的继承保护级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.</span> <span class="toc-text">继承中的类作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.1.</span> <span class="toc-text">在编译时进行名字查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">名字冲突与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9D%A5%E4%BD%BF%E7%94%A8%E9%9A%90%E8%97%8F%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">7.3.</span> <span class="toc-text">通过作用域运算符来使用隐藏的成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%A6%82%E5%BE%80%E5%B8%B8%EF%BC%8C%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E5%85%88%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">7.4.</span> <span class="toc-text">一如往常，名字查找先于类型检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.5.</span> <span class="toc-text">虚函数与作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">覆盖重载的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">构造函数与拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">虚析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%B0%86%E9%98%BB%E6%AD%A2%E5%90%88%E6%88%90%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.1.</span> <span class="toc-text">虚析构函数将阻止合成移动操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">8.2.</span> <span class="toc-text">合成拷贝控制与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E5%88%A0%E9%99%A4%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.2.1.</span> <span class="toc-text">派生类中删除的拷贝控制与基类的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">8.2.2.</span> <span class="toc-text">移动操作与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="toc-number">8.3.</span> <span class="toc-text">派生类的拷贝控制成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%88%96%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.1.</span> <span class="toc-text">定义派生类的拷贝或移动构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.3.2.</span> <span class="toc-text">派生类赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.3.</span> <span class="toc-text">派生类析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.4.</span> <span class="toc-text">在构造函数和析构函数中调用虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">继承的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.4.1.</span> <span class="toc-text">继承的构造函数的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">9.</span> <span class="toc-text">容器与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%94%BE%E7%BD%AE%E6%8C%87%E9%92%88%E8%80%8C%E9%9D%9E%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.1.</span> <span class="toc-text">在容器中放置指针而非对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99Basket%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">编写Basket类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十五章：面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计">第十五章：面向对象程序设计</a><time datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四章：重载运算与类型转换"/></a><div class="content"><a class="title" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换">第十四章：重载运算与类型转换</a><time datetime="2025-12-28T14:40:27.817Z" title="发表于 2025-12-28 22:40:27">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(五)：实现"/></a><div class="content"><a class="title" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现">(五)：实现</a><time datetime="2025-12-27T05:12:38.578Z" title="发表于 2025-12-27 13:12:38">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十三章：拷贝控制"/></a><div class="content"><a class="title" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制">第十三章：拷贝控制</a><time datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十二章：动态内存"/></a><div class="content"><a class="title" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存">第十二章：动态内存</a><time datetime="2025-12-22T12:49:57.719Z" title="发表于 2025-12-22 20:49:57">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>