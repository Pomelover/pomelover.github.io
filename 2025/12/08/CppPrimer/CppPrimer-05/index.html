<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第六章：函数 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="函数 简介​	函数是一个命名了的代码块，我们允许调用函数执行相应的代码，函数可以有0个或者多个参数，而且通常会产生一个结果。C++也允许重载函数，也就是说，同一个名字可以对应几个不同的函数。  函数基础简要介绍​	一个典型的函数定义包括以下部分：  返回类型 函数名字 形参组成列表 函数体  ​	其中，形参以逗号隔开，形参的列表位于一对圆括号之内，函数执行的操作在语句块中说明，该语句块称为函数体。">
<meta property="og:type" content="article">
<meta property="og:title" content="第六章：函数">
<meta property="og:url" content="https://pomelover.github.io/2025/12/08/CppPrimer/CppPrimer-05/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="函数 简介​	函数是一个命名了的代码块，我们允许调用函数执行相应的代码，函数可以有0个或者多个参数，而且通常会产生一个结果。C++也允许重载函数，也就是说，同一个名字可以对应几个不同的函数。  函数基础简要介绍​	一个典型的函数定义包括以下部分：  返回类型 函数名字 形参组成列表 函数体  ​	其中，形参以逗号隔开，形参的列表位于一对圆括号之内，函数执行的操作在语句块中说明，该语句块称为函数体。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/cpp_logo.png">
<meta property="article:published_time" content="2025-12-08T03:54:23.951Z">
<meta property="article:modified_time" content="2025-12-11T16:28:50.950Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ Primer">
<meta property="article:tag" content="C++ 学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/cpp_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第六章：函数",
  "url": "https://pomelover.github.io/2025/12/08/CppPrimer/CppPrimer-05/",
  "image": "https://pomelover.github.io/images/cpp_logo.png",
  "datePublished": "2025-12-08T03:54:23.951Z",
  "dateModified": "2025-12-11T16:28:50.950Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/08/CppPrimer/CppPrimer-05/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第六章：函数',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">第六章：函数</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">第六章：函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-08T03:54:23.951Z" title="发表于 2025-12-08 11:54:23">2025-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-11T16:28:50.950Z" title="更新于 2025-12-12 00:28:50">2025-12-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="函数-简介"><a href="#函数-简介" class="headerlink" title="函数 简介"></a>函数 简介</h1><p>​	函数是一个命名了的代码块，我们允许调用函数执行相应的代码，函数可以有0个或者多个参数，而且通常会产生一个结果。<code>C++</code>也允许重载函数，也就是说，同一个名字可以对应几个不同的函数。</p>
<hr>
<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>​	一个典型的函数定义包括以下部分：</p>
<ul>
<li>返回类型</li>
<li>函数名字</li>
<li>形参组成列表</li>
<li>函数体</li>
</ul>
<p>​	其中，形参以逗号隔开，形参的列表位于一对圆括号之内，函数执行的操作在语句块中说明，该语句块称为函数体。我们通过调用运算符来执行函数。调用运算符的形式是一对圆括号，作用于一个表达式，该表达式时函数或者指向函数的指针，圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数形参，调用表达式的类型就是函数的返回类型。</p>
<h3 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>) ret *= val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面的函数中，<code>fact</code>是函数名字，其作用于一个整型参数，返回一个整型值。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>​	要调用<code>fact</code>函数，必须提供一个整数值，调用得到的结果也是一个整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>​	函数的调用主要完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数执行被暂时中断，被调函数开始执行。</p>
<p>​	当遇到一条<code>return</code>语句时，函数结束执行过程，和函数调用一样，<code>return</code>语句也完成了两项工作，一是返回<code>return</code>语句中的值，二是将控制权从被调函数转移回主调函数。</p>
<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>​	<strong>实参是形参的初始值。</strong>实参的类型必须与对应形参类型匹配。</p>
<h3 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h3><p>​	<strong>函数的形参列表可以为空，但不能省略。</strong>你也可以通过<code>void</code>表示函数没有形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>​	形参列表中的形参通常用逗号隔开，每个形参都是一个声明符的声明。即使形参类型相同，也必须把每个的类型都写出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, v2)</span> <span class="comment">// 错误</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> <span class="comment">// 正确</span></span></span><br></pre></td></tr></table></figure>

<p>​	<strong>任意两个形参都不能同名，并且最外层作用域中的局部变量也不能使用与函数形参一样的名字。</strong></p>
<h3 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h3><p>​	大多数类型都能作为函数的返回类型，一种特殊的返回类型是<code>void</code>，它表示函数不返回任何值，<strong>函数返回类型不能是数组类型或者函数类型，但可以是指向数组或函数的指针。</strong></p>
<h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><p>​	<code>C++</code>语言中，名字有作用域，对象有生命周期：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见；</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间；</li>
</ul>
<p>​	形参和函数体内部定义的变量统称为局部变量，它们对函数而言是局部的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p>
<p>​	<strong>在所有函数体之外定义的对象存在与程序的整个执行过程中，此类对象在程序启动时被创建，直到程序结束时才会销毁，局部变量的生命周期依赖于定义的方式。</strong></p>
<h3 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h3><p>​	对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在块末尾时销毁它，我们把只存在于块执行期间的对象称为<strong>自动对象</strong>。当块执行结束后，我们的自动对象的值变为未定义。</p>
<p>​	形参是一种自动对象，函数开始时为其申请存储空间，一旦函数终止，形参也就被销毁。我们用传递给函数的实参初始化形参对应的自动对象。</p>
<p>​	对于局部对象对应的自动对象来说，分为两种情况，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。</p>
<h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><p>​	某些时候，有必要令局部变量的生命周期贯穿函数调用以及之后的时间，可以把局部变量定义成<code>static</code>类型从而获得这样的对象。<strong>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数执行也不会对它有什么影响。</strong></p>
<p>​	如果局部静态变量没有显式初始值，那么它将执行值初始化。</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>​	和其它名字一样，函数的名字也必须在使用之前声明，类似于变量，<strong>函数只能定义一次，但可以声明多次。</strong>函数的声明和定义非常类似，<strong>唯一的区别是无须函数体，用一个分号替代即可</strong>。</p>
<p>​	函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了该函数所需的全部信息，<strong>函数声明也称作函数原型。</strong></p>
<h3 id="在头文件中进行函数声明"><a href="#在头文件中进行函数声明" class="headerlink" title="在头文件中进行函数声明"></a>在头文件中进行函数声明</h3><p>​	我们建议变量在头文件中声明，在源文件中定义，与之类似，<strong>函数也应该在头文件中声明而在源文件中定义。</strong></p>
<p>​	<strong>定义函数的源文件应该把含有函数声明的头文件包含进来</strong>，编译器负责验证函数的定义和声明是否匹配。</p>
<h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h2><p>​	随着程序越来越复杂，<strong>我们希望把程序的各个部分分别存储在不同的文件中</strong>。<code>C++</code>支持分离式编译，允许我们把程序分隔到几个文件中，每个文件独立编译。</p>
<h3 id="编译和链接多个源文件"><a href="#编译和链接多个源文件" class="headerlink" title="编译和链接多个源文件"></a>编译和链接多个源文件</h3><p>​	假设<code>fact</code>的函数定义位于名为<code>fact.cc</code>的文件中，它的声明位于名为<code>Chapter6.h</code>的头文件中，显然与其它所有用到<code>fact</code>函数的文件一样，<code>fact.cc</code>应该包含<code>Chapter6.h</code>的头文件，另外，我们在名为<code>factMain.cc</code>的文件中创建<code>main</code>函数，<code>main</code>函数将调用<code>fact</code>函数，要生成可执行文件，必须告诉编译器我们用到的代码在哪。</p>
<hr>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>​	每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。形参初始化的机理和变量初始化一样。</p>
<p>​	当形参是引用类型时，我们说它对应的实参被引用传递，或者函数被传引用调用。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，我们说这样的实参被值传递或者函数被传值调用。</p>
<h2 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h2><p>​	<strong>当初始化一个非引用类型的变量时，初始值被拷贝给变量。</strong>函数对形参做到所有操作都不会影响实参。</p>
<h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>​	指针的行为和其它非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝后，两个指针是两个不同的指针。因为指针使我们可以间接访问它所指的对象，所以我们通过指针可以修改它所指对象的值。</p>
<blockquote>
<p>在<code>C++</code>语言中，建议使用引用类型的形参替代指针。</p>
</blockquote>
<h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><p>​	我们知道对于引用的操作，实际上是作用在引用所引对象上。<strong>引用形参的行为与之类似，通过使用引用参数，允许函数改变一个或多个实参的值。</strong></p>
<h3 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h3><p>​	拷贝大的类类型对象或者容器对象比较低效，有一些类根本不支持拷贝操作。当某种类型不支持拷贝操作时，我们只能通过引用形参访问该类型的对象。</p>
<blockquote>
<p><strong>如果函数无须改变引用形参的值，最好将其声明为常量引用。</strong></p>
</blockquote>
<h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p>​	一个函数只能返回一个值，然而有时函数需要同时返回多个值，<strong>引用形参为我们一次返回多个结果提供了有效的途径。</strong></p>
<h2 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><code>const</code>形参和实参</h2><p>​	当形参是<code>const</code>时，必须注意到我们关于顶层<code>const</code>的讨论。使用实参初始化形参时，会忽略掉顶层<code>const</code>，当形参有顶层<code>const</code>时，传给它常量对象或者非常量对象都是可以的。</p>
<p>​	在<code>C++</code>语言中，允许我们定义若干相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。因为<code>const</code>被忽略掉了，所以以下定义是错误的，因为尽管形式上有区别，但实际上形参是没区别的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> i)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与<code>const</code></h3><p>​	形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层<code>const</code>对象，但反过来不行；同时一个普通的引用必须用同类型的对象初始化。</p>
<h3 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h3><p>​	<strong>把函数不会改变的形参定义成普通引用是比较常见的错误。此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。</strong></p>
<p>​	例如我们有如下函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">find_char</span><span class="params">(string &amp;s, <span class="type">char</span> c, string::size_type &amp;occurs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	那么我们无法如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_char</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;o&#x27;</span>, ctr);</span><br></pre></td></tr></table></figure>

<p>​	还有一个更加难以察觉的问题，当其它函数正确使用了常量引用，然后调用时，也无法使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sentence</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_char</span>(s, <span class="string">&#x27;.&#x27;</span>, ctr) == s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; ctr == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由于<code>s</code>为常量引用，但<code>find_char</code>只能接受普通引用。</p>
<h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p>​	数组的两个特殊性质使得我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组以及使用数组时会将其转换成指针。<strong>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</strong></p>
<p>​	尽管不能以值传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	上面三个函数是等价的，当编译器对<code>print</code>函数调用时，只检查传入参数是否是<code>const int*</code>类型。和其它使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。因为数组是以指针的形式传递给函数的，所以调用者应该为此提供一些额外的信息。</p>
<h3 id="使用标记指定数组长度"><a href="#使用标记指定数组长度" class="headerlink" title="使用标记指定数组长度"></a>使用标记指定数组长度</h3><p>​	管理数组实参的第一种方法是要求数组本身包含一个结束标记（最经典的例子是<code>C</code>风格字符串）。</p>
<h3 id="使用标准库规范"><a href="#使用标准库规范" class="headerlink" title="使用标准库规范"></a>使用标准库规范</h3><p>​	管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针。</p>
<h3 id="显式传递一个表示数组大小的形参"><a href="#显式传递一个表示数组大小的形参" class="headerlink" title="显式传递一个表示数组大小的形参"></a>显式传递一个表示数组大小的形参</h3><p>​	第三种管理实参的方法是专门定义一个表示数组大小的形参。</p>
<h3 id="数组形参和const"><a href="#数组形参和const" class="headerlink" title="数组形参和const"></a>数组形参和<code>const</code></h3><p>​	当函数不需要对数组元素执行写操作的时候，数组的形参应该是指向<code>const</code>的指针。</p>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>​	<code>C++</code>语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	<code>&amp;arr</code>两边的括号必不可少：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> &amp;arr[<span class="number">10</span>])</span></span>;	<span class="comment">// 将数组错误声明成了引用的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h3><p>​	和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>(*matrix)[<span class="number">10</span>], <span class="type">int</span> rowsize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	上述语句将<code>matrix</code>声明成指向含有10个整数的数组的指针。我们也可以使用数组的语法定义函数，此时编译器会一如既往的忽略第一个维度，所以最好不要把他包括在形参列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a><code>main</code>：处理命令行选项</h2><p>​	<code>main</code>函数是演示<code>C++</code>程序如何向函数传递数组的好例子。命令行选项是通过两个可选的形参传递给<code>main</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h2><pre><code> 为了能处理不同数量实参的函数，`C++11`提供了两种主要的方法：如果所有的实参类型相同，可以传递一个`initializer_list`的标准库类型；类型不同，我们也可以编写一种特殊的函数，也就是所谓的可变参数模板。
</code></pre>
<h3 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a><code>initializer_list</code>形参</h3><p>​	<code>initializer_list</code>是一种标准库类型，用于表示某种特定类型的值的数组，以下是其主要操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt; lst; 	<span class="comment">// 默认初始化</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;  </span><br><span class="line">	<span class="comment">// lst元素数量和初始值一样多，lst的元素是对应初始值的副本；列表中的元素是const</span></span><br><span class="line"><span class="built_in">lst2</span>(lst);	<span class="comment">// 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；</span></span><br><span class="line">lst2 = lst;	<span class="comment">// 拷贝后，原始列表和副本共享元素；</span></span><br><span class="line">lst.<span class="built_in">size</span>(); <span class="comment">// 列表中的元素数量</span></span><br><span class="line">lst.<span class="built_in">begin</span>()/lst.<span class="built_in">end</span>();	<span class="comment">// 返回首元素/尾后指针</span></span><br></pre></td></tr></table></figure>

<p>​	<code>initializer_list</code>也是一种模板类型，定义其对象时，必须说明列表中所占元素的类型；其对象中元素永远是常量值，我们无法改变其元素的值。</p>
<h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>​	省略符形参是为了便于<code>C++</code>程序访问某些特殊的<code>C</code>代码而设置的，这些代码使用了名为<code>varargs</code>的<code>C</code>标准库功能。省略符形参应该仅仅用于<code>C</code>和<code>C++</code>通用的类型。大多数类类型的对象在传递给省略符形参时都无法正确拷贝。省略符形参只能出现在形参列表的最后一个位置，形式无外乎两种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(params, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和<code>return</code>语句</h1><p>​	<code>return</code>语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。其有两种形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;  <span class="comment">// method 1</span></span><br><span class="line"><span class="keyword">return</span> expression;  <span class="comment">// method 2</span></span><br></pre></td></tr></table></figure>

<h2 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h2><p>​	没有返回值的<code>return</code>语句只能在返回值类型为<code>void</code>的函数中，返回<code>void</code>的函数也不要求一定有<code>return</code>语句，这类函数最后一句会隐式执行<code>return</code>。</p>
<p>​	一个返回类型是<code>void</code>的函数也能使用<code>return</code>语句的第二种形式，不过此时，<code>return</code>语句的<code>expression</code>必须是另一个返回<code>void</code>的函数。</p>
<h2 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h2><p>​	<code>return</code>语句的第二种形式提供了函数的结果。只要函数返回类型不是<code>void</code>，则该函数内的每条<code>return</code>语句必须返回一个值。**<code>return</code>语句返回值类型必须与返回类型相同，或者能隐式转换成函数的返回类型。**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">str_subrange</span><span class="params">(<span class="type">const</span> string &amp;str1, <span class="type">const</span> string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str<span class="number">1.</span><span class="built_in">size</span>()==str<span class="number">2.</span><span class="built_in">size</span>()) <span class="keyword">return</span> str1==str2;</span><br><span class="line">    <span class="keyword">auto</span> size = (str<span class="number">1.</span><span class="built_in">size</span>() &lt; str<span class="number">2.</span><span class="built_in">size</span>()) ? str<span class="number">1.</span><span class="built_in">size</span>() : str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">decltype</span>(size) i = <span class="number">0</span>; i != size; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str2[i]) <span class="keyword">return</span>; <span class="comment">// 错误！没有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误！可能没有任何返回值就结束了函数的执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述代码主要有两个错误：</p>
<ol>
<li><code>for</code>循环的<code>return</code>语句是错误的，因为它没有返回值；</li>
<li><code>for</code>循环之后没有提供<code>return</code>语句，编译器也许能检测到这个错误，也许不能；如果没有发现，则运行时行为将是未定义的。</li>
</ol>
<blockquote>
<p>在含有<code>return</code>语句的循环后面应该也有<code>return</code>语句，如果没有的话，就是错误的！</p>
</blockquote>
<h3 id="值是如何被返回的"><a href="#值是如何被返回的" class="headerlink" title="值是如何被返回的"></a>值是如何被返回的</h3><p>​	返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，这个临时量就是函数调用的结果。</p>
<h3 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h3><p>​	函数完成时，它所占有的存储空间也随之被释放掉。因此，这意味着局部变量的引用将指向不再有效的内存区域。所以我们不应返回局部对象的引用或指针。</p>
<h3 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a>返回类类型的函数和调用运算符</h3><p>​	调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = <span class="built_in">shorterString</span>(s1, s2).<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h3 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h3><p>​	函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其它返回类型得到右值。可以像使用其它左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// s: A value</span></span><br></pre></td></tr></table></figure>

<p>​	如果返回类型是常量引用，我们不能给调用的结果赋值。</p>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>​	<code>C++11</code>还规定，函数可以返回花括号包围的值的列表。</p>
<h3 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数<code>main</code>的返回值</h3><p>​	主函数<code>main</code>可以没有返回语句，编译器将隐式插入一条返回0的<code>return</code>语句。<code>main</code>函数的返回值可以看作是状态指示器，返回0表示执行成功，返回其它值表示执行失败。其中非0值的具体含义依机器而定。为了使返回值与机器无关，<code>cstdlib</code>头文件定义了两个预处理变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXIT_FAILURE</span><br><span class="line">EXIT_SUCCESS</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>​	如果一个函数调用了它自身，不管这种调用是直接的或者间接的，都称该函数为递归函数。</p>
<blockquote>
<p><code>main</code>函数不能调用它自己。</p>
</blockquote>
<h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><p>​	因为数组不能被拷贝，所以函数不能返回数组。但函数可以返回数组的指针或引用。要想定义一个返回数组的引用或指针的函数比较烦琐，但是有一些方法可以简化，最直接的方法是使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> attT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	上述函数接受一个<code>int</code>实参，返回一个指向包含10个整数的数组的指针。</p>
<h3 id="声明一个返回数组指针的函数"><a href="#声明一个返回数组指针的函数" class="headerlink" title="声明一个返回数组指针的函数"></a>声明一个返回数组指针的函数</h3><p>​	要想在声明<code>func</code>时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>​	和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后，然而，函数的形参列表也跟在函数名字且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list))[dimension]</span><br></pre></td></tr></table></figure>

<h3 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h3><p>​	还有一种可以简化上述<code>func</code>声明的方法，就是使用尾置返回类型。任何函数的定义都能使用尾置返回类型。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。</p>
<p>​	尾置返回类型跟在形参列表后面并以一个<code>-&gt;</code>开头，为了表示函数真正的返回类型跟在形参列表之后，我们在本应出现返回类型的地方放置一个<code>auto</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用<code>decltype</code></h3><p>​	如果我们知道函数返回的指针将指向哪个数组，就可以使用<code>decltype</code>关键字声明返回类型。</p>
<hr>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="简要介绍-1"><a href="#简要介绍-1" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>​	如果同一作用域内的函数名字相同但形参列表不同，我们称作重载函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[])</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>​	这些函数接受的形参类型不同，但是执行的操作非常相似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。</p>
<blockquote>
<p><code>main</code>不能被重载。</p>
</blockquote>
<h3 id="定义重载函数"><a href="#定义重载函数" class="headerlink" title="定义重载函数"></a>定义重载函数</h3><p>​	对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其它所有的要素都相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 错误！不允许只有返回类型不同！</span></span><br></pre></td></tr></table></figure>

<h3 id="判断两个形参的类型是否相异"><a href="#判断两个形参的类型是否相异" class="headerlink" title="判断两个形参的类型是否相异"></a>判断两个形参的类型是否相异</h3><p>​	有时候，两个形参列表看起来不一样，但实际上是相同的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和<code>const</code>形参</h3><p>​	顶层<code>const</code>不影响传入函数的对象，一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>; <span class="comment">// 重复声明了 Record lookup(Phone)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="type">const</span>)</span></span>; <span class="comment">// 重复声明了 Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>

<p>​	另一方面，如果形参是某种类型的指针或引用，则区分其指向的是常量对象还是非常量对象可以实现函数重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	编译器可以通过实参来判断应该调用哪个函数。因为<code>const</code>不能转换成其它类型，所以我们只能把<code>const</code>对象传递给<code>const</code>形参；<strong>另一方面，因为非常量可以转换成<code>const</code>，所以上面的四个函数都能作用于非常量对象或者指向非常量对象的指针。</strong>但编译器会优先选用不需要类型转换的函数版本。</p>
<blockquote>
<p>何时不应该重载函数：尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作，有些情况下，给函数起不同名字能使得程序更易理解。</p>
</blockquote>
<h3 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a><code>const_cast</code>和重载</h3><p>​	<code>const_cast</code>在重载函数的情景中最有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                           <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h3><p>​	定义了一组重载函数，我们需要以合理的实参调用它们。<strong>函数匹配是指一个过程，在这个过程中，我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。</strong>编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果调用哪个函数。</p>
<p>​	当两个重载函数参数数量相同且参数类型可以相互转换时，编译器选择函数比较困难。</p>
<p>​	当调用重载函数时，有三种可能的结果：</p>
<ul>
<li>编译器找到一个最佳匹配，并生成调用该函数的代码；</li>
<li>找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息；</li>
<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时发生错误，称为<strong>二义性调用</strong>；</li>
</ul>
<h2 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h2><p>​	重载对作用域的一般性质并没有什么改变，如果我们在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> read = <span class="literal">false</span>;</span><br><span class="line">    string s = <span class="built_in">read</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value: &quot;</span>); <span class="comment">// 错误！void print(const string&amp;)被隐藏了！</span></span><br><span class="line">    <span class="built_in">pring</span>(ival);  <span class="comment">// 正确！当前print(int)可见！</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);  <span class="comment">// 正确！调用print(int)！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>C++</code>语言中，名字查找发生在类型检查之前。</p>
</blockquote>
<hr>
<h1 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h1><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>​	某些函数有这样一种形参，在函数的很多次调用中，它们都被赋予了一个相同的值，此时我们把这个反复出现的指称为函数的<strong>默认实参</strong>。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">size_t</span> ht = <span class="number">24</span>, <span class="type">size_t</span> wid = <span class="number">80</span>, <span class="type">char</span> background = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中。<strong>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值！</strong></p>
<h3 id="使用默认实参调用函数"><a href="#使用默认实参调用函数" class="headerlink" title="使用默认实参调用函数"></a>使用默认实参调用函数</h3><p>​	如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。函数调用时实参按其位置解析，默认实参负责填补函数调用的尾部实参。</p>
<p>​	当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p>
<h3 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h3><p>​	对于函数的声明来说，通常习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。需要注意的是，在给定的作用域中，一个形参只能被赋予一次默认实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	我们不能修改一个已经存在的默认值，但是可以按照如下形式添加默认实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> width = <span class="number">24</span>, <span class="type">int</span> height = <span class="number">80</span>, <span class="type">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
</blockquote>
<h3 id="默认实参初始化"><a href="#默认实参初始化" class="headerlink" title="默认实参初始化"></a>默认实参初始化</h3><p>​	<strong>局部变量不能作为默认参数！除此之外，只要表达式的类型能转换成形参的类型，该表达式就能作为默认实参。</strong></p>
<h2 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和<code>constexpr</code>函数</h2><p>​	将小规模操作定义成函数有很多好处：</p>
<ol>
<li>阅读和理解函数比读懂等价条件表达式容易得多；</li>
<li>使用函数可以确保行为的统一；</li>
<li>如果需要进行修改，修改函数比先找到等价表达式所有出现的地方再逐一修改更容易；</li>
<li>函数可以被其它应用继续调用，省去了重新编写的代价；</li>
</ol>
<p>​	但是：调用函数一般比求等价表达式的值慢一些，在大多数机器上，一次函数调用包含着一系列工作，调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</p>
<h3 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h3><p>​	<strong>将函数指定为内联函数，通常就是在它在每个调用点上内联展开。</strong>例如我们定义如下函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b;&#125;</span><br></pre></td></tr></table></figure>

<p>​	那么当我们遇到如下调用时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">add</span>(a,b) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>​	将在编译过程中展开成类似于下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (a + b) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>​	从而消除了函数的运行时开销。<code>inline</code>关键字，就可以声明函数为内联函数。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。</p>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p>​	<strong><code>constexpr</code>函数是指能用于常量表达式的函数。</strong>定义<code>constexpr</code>函数的方法与其它函数类似，但是要遵循几项约定：<strong>函数的返回值及所有形参的类型都得是字面值类型，而且函数体必须有且只有一条<code>return</code>语句</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();</span><br></pre></td></tr></table></figure>

<p>​	我们将<code>new_sz</code>定义成无参数的<code>constexpr</code>函数，因为编译器能在程序编译时验证<code>new_sz</code>返回的是常量表达式，所以可以用<code>new_sz</code>函数初始化<code>constexpr</code>类型的函数<code>foo</code>。执行该初始化任务时，编译器把对<code>constexpr</code>函数的调用替换成其结果值，为了能在编译过程中随时展开，<code>constexpr</code>函数被隐式指定为内联函数。</p>
<p>​	<code>constexpr</code>函数体内也可以包含其它语句，只要这些语句在运行时不执行任何操作。</p>
<p>​	我们允许<code>constexpr</code>函数的返回值并非一个常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;&#125;</span><br></pre></td></tr></table></figure>

<p>​	当<code>scale</code>的实参是常量表达式时，它的返回值也是常量表达式，反之则不然。当我们给其传入非常量表达式调用<code>scale</code>函数时，则返回值是一个非常量表达式。当<code>scale</code>函数用在需要常量表达式的上下文中，由编译器负责检查函数的结果是否符合要求。</p>
<blockquote>
<p><code>constexpr</code>函数不一定返回常量表达式。</p>
</blockquote>
<h3 id="把内联函数和constexpr函数放在头文件中"><a href="#把内联函数和constexpr函数放在头文件中" class="headerlink" title="把内联函数和constexpr函数放在头文件中"></a>把内联函数和<code>constexpr</code>函数放在头文件中</h3><p>​	<strong>对于某个给定的内联函数或者<code>constexpr</code>函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和<code>constexpr</code>函数通常定义在头文件中。</strong></p>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>​	<code>C++</code>程序员有时会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用，当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项与处理功能：<code>assert</code>和<code>NDEBUG</code>。</p>
<h3 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a><code>assert</code>预处理宏</h3><p>​	<strong><code>assert</code>是一种预处理宏。</strong>所谓预处理宏其实是一个预处理变量，它的行为类似于内联函数。<code>assert</code>宏使用一个表达式作为它的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(expr);</span><br></pre></td></tr></table></figure>

<p>​	首先对表达式求值，如果表达式为假，则<code>assert</code>输出信息并终止程序的执行。如果表达式为真，则<code>assert</code>什么也不做。<code>assert</code>宏定义在<code>cassert</code>头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供<code>using</code>说明。</p>
<p>​	<strong>和预处理变量意义，宏名字在程序内必须唯一。</strong>含有<code>cassert</code>头文件的程序不能再定义<code>assert</code>的变量、函数或者其他实体。**<code>assert</code>宏用于检查不能发生的条件。**</p>
<h3 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a><code>NDEBUG</code>预处理变量</h3><p>​	<code>assert</code>的行为依赖于一个名为<code>NDEBUG</code>的预处理变量的状态。如果定义了<code>NDEBUG</code>，则<code>assert</code>什么也不做。默认状态下没有定义<code>NDEBUG</code>，此时<code>assert</code>将执行运行时检查。</p>
<p>​	我们可以使用一个<code>#define</code>语句定义<code>NDEBUG</code>，从而关闭调试状态。同时很多编译器提供了一个命令行选项使我们可以定义预处理变量：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CC -D NDEBUG main.C <span class="comment"># use /D with the Microsoft compiler</span></span></span><br></pre></td></tr></table></figure>

<p>​	定义<code>NDEBUG</code>能避免检查各种条件所需的运行时开销，此时不会执行运行时检查。因此，<code>assert</code>应该仅用于验证那些确实不可能发生的事情，<strong>我们可以把<code>assert</code>当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</strong></p>
<p>​	除了用于<code>assert</code>外，我们也可以使用<code>NDEBUG</code>编写自己的条件调试代码，如果<code>NDEBUG</code>未定义，将执行<code>#ifndef</code>和<code>endif</code>之间的代码；如果定义了<code>NDEBUG</code>，这些代码将被忽略掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;:array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>__func__</code>是编译器定义的一个局部静态变量，用于存放函数的名字，这段代码中，我们使用<code>__func__</code>输出当前调试的函数的名字，编译器为每个函数都定义了<code>__func__</code>，它是<code>const char</code>的一个静态数组，用于存放函数的名字。</p>
<p>​	除了<code>C++</code>编译器定义的<code>__func__</code>之外，预处理器还定义了另外4个对于程序调试很有用的名字：</p>
<ol>
<li><code>__FILE__</code>存放文件名的字符串字面值；</li>
<li><code>__LINE__</code>存放当前行号的整型字面值；</li>
<li><code>__TIME__</code>存放文件编译时间的字符串字面值；</li>
<li><code>__DATA__</code>存放文件编译日期的字符串字面值；</li>
</ol>
<hr>
<h1 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	在大多数情况下，我们容易确定某次调用应该选用哪个重载函数，但当几个重载函数的形参数量相等时以及某些形参的类型可以由其它类型转换得来时，这项工作就不那么容易。</p>
<h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>​	函数匹配的第一步是选定本次调用的重载函数集，集合中的函数称为候选函数，候选函数具备两个特征：</p>
<ol>
<li>与被调用函数<strong>同名</strong>；</li>
<li>其声明在调用点<strong>可见</strong>；</li>
</ol>
<p>​	第二步，我们考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。<strong>可行函数</strong>也有两个特征：</p>
<ol>
<li>其<strong>形参数量与本次调用提供的实参数量相同</strong>；</li>
<li>每个实参的类型与其对应形参<strong>类型相同</strong>，<strong>或者能转换成形参的类型</strong>；</li>
</ol>
<blockquote>
<p><strong>如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。</strong></p>
</blockquote>
<p>​	在使用是参数来初步判别候选函数后，接下来考察函数的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。</p>
<blockquote>
<p>如果没找到可行函数，编译器将报告无匹配函数的错误。</p>
</blockquote>
<h3 id="寻找最佳匹配"><a href="#寻找最佳匹配" class="headerlink" title="寻找最佳匹配"></a>寻找最佳匹配</h3><p>​	函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，<strong>注意检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数</strong>。寻找最匹配的基本思想是：实参类型与形参类型越接近，其匹配得越好。</p>
<h3 id="含有多个形参的函数匹配"><a href="#含有多个形参的函数匹配" class="headerlink" title="含有多个形参的函数匹配"></a>含有多个形参的函数匹配</h3><p>​	多个形参匹配时，问题变得复杂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>, <span class="number">2.56</span>);</span><br></pre></td></tr></table></figure>

<p>​	如果有且仅有一个函数满足下列条件，则满足最佳匹配：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其它可行函数需要的匹配；</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配；</li>
</ul>
<p>​	<strong>如果在检查了所有实参之后，没有任何一个函数脱颖而出，则该调用是错误的，编译器将报告二义性调用的信息。</strong></p>
<blockquote>
<p><strong>调用重载函数时，应尽量避免强制类型转换，如果在实际应用中确实需要强制类型转换，那说明我们设计的形参集合不合理。</strong></p>
</blockquote>
<h2 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h2><p>​	为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下：</p>
<ol>
<li>精确匹配，有如下几种情况：<ul>
<li>实参类型和形参类型相同；</li>
<li>实参从数组类型或函数类型转换成对应的指针类型；</li>
<li>向实参添加顶层<code>const</code>或者从实参中删除顶层<code>const</code>；</li>
</ul>
</li>
<li>通过<code>const</code>转换实现的匹配；</li>
<li>通过类型提升实现的匹配；</li>
<li>通过算术类型转换实现的匹配；</li>
<li>通过类类型转换实现的匹配；</li>
</ol>
<h3 id="需要类型提升和算术类型转换的而匹配"><a href="#需要类型提升和算术类型转换的而匹配" class="headerlink" title="需要类型提升和算术类型转换的而匹配"></a>需要类型提升和算术类型转换的而匹配</h3><blockquote>
<p>内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在设计良好的系统中，函数很少会含有与下面例子类似的形参。</p>
</blockquote>
<p>​	我们知道，小整型一般都会提升到<code>int</code>类型或者更大的整数类型。假设有两个函数，一个接受<code>int</code>，一个接受<code>short</code>，则只有当调用的是<code>short</code>类型的值时才会选择<code>short</code>版本的函数，有时候，即使实参是一个很小的整数值，也会直接将它提升成<code>int</code>类型，此时使用<code>short</code>版本反而会导致类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="built_in">ff</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 调用ff(int)</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>所有算术类型转换的级别都一样。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">3.14</span>); <span class="comment">// 错误！二义性调用</span></span><br></pre></td></tr></table></figure>

<h3 id="函数类型和const实参"><a href="#函数类型和const实参" class="headerlink" title="函数类型和const实参"></a>函数类型和<code>const</code>实参</h3><p>​	<strong>如果重载函数的区别在于它们的应用类型的形参是否引用了<code>const</code>，或者指针类型的形参是否指向<code>const</code>，则当调用发生时，编译器通过实参是否是常量来选择哪个函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"><span class="built_in">lookup</span>(a);	<span class="comment">// 调用Record lookup(const Account&amp;);</span></span><br><span class="line"><span class="built_in">lookup</span>(b);	<span class="comment">// 调用Record lookup(Account&amp;);</span></span><br></pre></td></tr></table></figure>

<p>​	指针类型与引用类型类似。</p>
<hr>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>​	函数指针指向的时函数而非对象，和其它指针一样，<strong>函数指针指向某种特定类型</strong>。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lenCompare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	该函数类型是<code>bool(const string&amp;, const string&amp;)</code>。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;); <span class="comment">// 未初始化</span></span><br></pre></td></tr></table></figure>

<p>​	从我们的声明的名字开始观察，<code>pf</code>前面有一个指针，因此<code>pf</code>是指针；右侧是形参列表，表示<code>pf</code>指向的是函数；再观察左侧，发现函数的返回类型是布尔值，因此<code>pf</code>就是一个指向函数的指针，其中该函数的参数是两个<code>const string</code>的引用，返回值是<code>bool</code>类型。</p>
<blockquote>
<p><code>*pf</code>两侧的括号必不可少。</p>
</blockquote>
<h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><p>​	<strong>当我们把函数名作为一个值来使用，该函数自动转换为指针。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lenCompare;</span><br><span class="line">pf = &amp;lenCompare; <span class="comment">// 等价赋值语句，取地址符是可选的</span></span><br></pre></td></tr></table></figure>

<p>​	此外，我们还能直接用指向函数的指针调用该函数，无须提前解引用指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>); <span class="comment">// 等价调用</span></span><br></pre></td></tr></table></figure>

<p>​	在指向不同函数类型的指针间，不存在转换规则。但是和往常一样，我们可以为函数指针赋一个<code>nullptr</code>或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。</p>
<h3 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h3><p>​	当我们使用重载函数时，上下文必须清晰界定到底使用哪个函数，如果定义了指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*pf)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">// pf1指向ff(unsigned)</span></span><br></pre></td></tr></table></figure>

<p>​	编译器通过指针类型选用哪个函数，指针类型必须与重载函数中的某一个<strong>精确匹配</strong>！</p>
<h3 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h3><p>​	和数组类似，我们不能定义函数类型的形参，但是我们可以定义指向函数的指针形参。此时，形参看似是函数类型，实际上是当成指针使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, <span class="type">bool</span> pf(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, <span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="comment">// 两种等价声明</span></span><br></pre></td></tr></table></figure>

<p>​	直接使用函数指针类型显得冗长而繁琐，我们同样可以使用类型别名去简化使用了函数指针的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;  <span class="comment">// 等价类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Funcp)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *Func2</span>;  <span class="comment">// 等价类型</span></span><br></pre></td></tr></table></figure>

<p>​	上述<code>Func</code>和<code>Func2</code>是函数类型，而<code>FuncP</code>和<code>FuncP2</code>是指针类型。注意<code>decltype</code>返回函数类型，此时不会将函数类型自动转换成指针类型。</p>
<h3 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h3><p>​	我们同样可以定义一个返回指向函数类型的指针的函数。最简单的方法是使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = (*<span class="type">int</span>)(<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 正确：f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// 错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 正确：f1返回指向函数的指针</span></span><br></pre></td></tr></table></figure>

<p>​	与形参不同的是，我们必须让返回值为指向函数的指针，而非函数，编译器不会发生自动转换。</p>
<p>​	我们也可以用下面的形式直接声明<code>f1</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>​	我们还可以用尾置返回类型的方式声明一个返回函数指针的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="将auto和decltype用于函数指针类型"><a href="#将auto和decltype用于函数指针类型" class="headerlink" title="将auto和decltype用于函数指针类型"></a>将<code>auto</code>和<code>decltype</code>用于函数指针类型</h3><p>​	如果我们明确知道返回的函数是哪个，就能使用<code>decltype</code>简化书写函数指针返回类型的过程。需要注意的是，要显式加上<code>*</code>以表明返回指针。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/08/CppPrimer/CppPrimer-05/">https://pomelover.github.io/2025/12/08/CppPrimer/CppPrimer-05/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++ Primer</a><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/12/09/EffectiveCpp/EffectiveCpp-02/" title="(二)：构造/析构/赋值运算"><img class="cover" src="/images/EffectiveC++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">(二)：构造/析构/赋值运算</div></div></div></a><a class="pagination-related  no-desc" href="/2025/12/07/CppPrimer/CppPrimer-04/" title="第五章：语句"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第五章：语句</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/05/CppPrimer/CppPrimer-02/" title="第三章：字符串、向量和数组"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-05</div><div class="info-item-2">第三章：字符串、向量和数组</div></div></div></a><a class="pagination-related no-desc" href="/2025/11/25/CppPrimer/CppPrimer-01/" title="第二章：变量和基本类型"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-25</div><div class="info-item-2">第二章：变量和基本类型</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/07/CppPrimer/CppPrimer-03/" title="第四章：表达式"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-07</div><div class="info-item-2">第四章：表达式</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/12/CppPrimer/CppPrimer-06/" title="第七章：类"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">第七章：类</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/07/CppPrimer/CppPrimer-04/" title="第五章：语句"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-07</div><div class="info-item-2">第五章：语句</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">第十一章：关联容器</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">函数 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">简要介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">编写函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">形参和实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">函数的形参列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">函数返回类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">局部对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">自动对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">局部静态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">2.3.</span> <span class="toc-text">函数声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">2.3.1.</span> <span class="toc-text">在头文件中进行函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">2.4.</span> <span class="toc-text">分离式编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">编译和链接多个源文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.</span> <span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">传值参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">指针形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">传引用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E9%81%BF%E5%85%8D%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.1.</span> <span class="toc-text">使用引用避免拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82%E8%BF%94%E5%9B%9E%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用引用形参返回额外信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">3.3.</span> <span class="toc-text">const形参和实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82%E4%B8%8Econst"><span class="toc-number">3.3.1.</span> <span class="toc-text">指针或引用形参与const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">尽量使用常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">3.4.</span> <span class="toc-text">数组形参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E8%AE%B0%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.4.1.</span> <span class="toc-text">使用标记指定数组长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E8%A7%84%E8%8C%83"><span class="toc-number">3.4.2.</span> <span class="toc-text">使用标准库规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-number">3.4.3.</span> <span class="toc-text">显式传递一个表示数组大小的形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82%E5%92%8Cconst"><span class="toc-number">3.4.4.</span> <span class="toc-text">数组形参和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82"><span class="toc-number">3.4.5.</span> <span class="toc-text">数组引用形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.6.</span> <span class="toc-text">传递多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%EF%BC%9A%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">3.5.</span> <span class="toc-text">main：处理命令行选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">含有可变形参的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initializer-list%E5%BD%A2%E5%8F%82"><span class="toc-number">3.6.1.</span> <span class="toc-text">initializer_list形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82"><span class="toc-number">3.6.2.</span> <span class="toc-text">省略符形参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.</span> <span class="toc-text">返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">无返回值函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">有返回值函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">值是如何被返回的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E6%88%96%E6%8C%87%E9%92%88"><span class="toc-number">4.2.2.</span> <span class="toc-text">不要返回局部对象的引用或指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.3.</span> <span class="toc-text">返回类类型的函数和调用运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E5%B7%A6%E5%80%BC"><span class="toc-number">4.2.4.</span> <span class="toc-text">引用返回左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.2.5.</span> <span class="toc-text">列表初始化返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0main%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.2.6.</span> <span class="toc-text">主函数main的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.2.7.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">返回数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">声明一个返回数组指针的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">使用尾置返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8decltype"><span class="toc-number">4.3.3.</span> <span class="toc-text">使用decltype</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">5.1.</span> <span class="toc-text">简要介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义重载函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%BD%A2%E5%8F%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E7%9B%B8%E5%BC%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">判断两个形参的类型是否相异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8Cconst%E5%BD%A2%E5%8F%82"><span class="toc-number">5.1.3.</span> <span class="toc-text">重载和const形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.4.</span> <span class="toc-text">const_cast和重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.5.</span> <span class="toc-text">调用重载的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.2.</span> <span class="toc-text">重载与作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">6.1.</span> <span class="toc-text">默认实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">使用默认实参调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E5%A3%B0%E6%98%8E"><span class="toc-number">6.1.2.</span> <span class="toc-text">默认实参声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.3.</span> <span class="toc-text">默认实参初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">内联函数和constexpr函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%8F%AF%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">6.2.1.</span> <span class="toc-text">内联函数可避免函数调用的开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">constexpr函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">6.2.3.</span> <span class="toc-text">把内联函数和constexpr函数放在头文件中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">6.3.</span> <span class="toc-text">调试帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#assert%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">assert预处理宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NDEBUG%E9%A2%84%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">NDEBUG预处理变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">7.</span> <span class="toc-text">函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%80%99%E9%80%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%AF%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">确定候选函数和可行函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">寻找最佳匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">7.1.3.</span> <span class="toc-text">含有多个形参的函数匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">实参类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%E5%92%8C%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%80%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">7.2.1.</span> <span class="toc-text">需要类型提升和算术类型转换的而匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8Cconst%E5%AE%9E%E5%8F%82"><span class="toc-number">7.2.2.</span> <span class="toc-text">函数类型和const实参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">8.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.1.1.</span> <span class="toc-text">使用函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.2.</span> <span class="toc-text">重载函数的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="toc-number">8.1.3.</span> <span class="toc-text">函数指针形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.4.</span> <span class="toc-text">返回指向函数的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86auto%E5%92%8Cdecltype%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">将auto和decltype用于函数指针类型</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十五章：面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计">第十五章：面向对象程序设计</a><time datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四章：重载运算与类型转换"/></a><div class="content"><a class="title" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换">第十四章：重载运算与类型转换</a><time datetime="2025-12-28T14:40:27.817Z" title="发表于 2025-12-28 22:40:27">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(五)：实现"/></a><div class="content"><a class="title" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现">(五)：实现</a><time datetime="2025-12-27T05:12:38.578Z" title="发表于 2025-12-27 13:12:38">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十三章：拷贝控制"/></a><div class="content"><a class="title" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制">第十三章：拷贝控制</a><time datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十二章：动态内存"/></a><div class="content"><a class="title" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存">第十二章：动态内存</a><time datetime="2025-12-22T12:49:57.719Z" title="发表于 2025-12-22 20:49:57">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>