<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第十三章：拷贝控制 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="拷贝控制 简介​	当定义一个类时，我们显式或隐式指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作：  拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数  ​	这些操作，我们称为拷贝控制操作。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。但是，对一些类来说，依赖这些默认定义的操作是灾难性的。通常，实现拷贝控">
<meta property="og:type" content="article">
<meta property="og:title" content="第十三章：拷贝控制">
<meta property="og:url" content="https://pomelover.github.io/2025/12/26/CppPrimer/CppPrimer-12/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="拷贝控制 简介​	当定义一个类时，我们显式或隐式指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作：  拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数  ​	这些操作，我们称为拷贝控制操作。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。但是，对一些类来说，依赖这些默认定义的操作是灾难性的。通常，实现拷贝控">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/cpp_logo.png">
<meta property="article:published_time" content="2025-12-26T14:17:58.722Z">
<meta property="article:modified_time" content="2025-12-28T14:40:09.942Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ Primer">
<meta property="article:tag" content="C++ 学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/cpp_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第十三章：拷贝控制",
  "url": "https://pomelover.github.io/2025/12/26/CppPrimer/CppPrimer-12/",
  "image": "https://pomelover.github.io/images/cpp_logo.png",
  "datePublished": "2025-12-26T14:17:58.722Z",
  "dateModified": "2025-12-28T14:40:09.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/26/CppPrimer/CppPrimer-12/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第十三章：拷贝控制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">第十三章：拷贝控制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">第十三章：拷贝控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-28T14:40:09.942Z" title="更新于 2025-12-28 22:40:09">2025-12-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="拷贝控制-简介"><a href="#拷贝控制-简介" class="headerlink" title="拷贝控制 简介"></a>拷贝控制 简介</h1><p>​	当定义一个类时，我们显式或隐式指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作：</p>
<ol>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ol>
<p>​	这些操作，我们称为拷贝控制操作。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。但是，对一些类来说，依赖这些默认定义的操作是灾难性的。通常，实现拷贝控制操作最困难的地方是首先认识到什么时候需要定义这些操作。</p>
<blockquote>
<p>在定义任何 C++ 类时，拷贝控制操作都是必要部分。对初学 C++ 的程序员来说，必须定义对象拷贝、移动、赋值或销毁时做什么，这常常令他们感到困惑。这种困扰很复杂，因为如果我们不显式定义这些操作，编译器也会为我们定义，但编译器定义的版本的行为可能并非我们所想。</p>
</blockquote>
<hr>
<h1 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h1><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>​	<strong>如果一个构造函数的第一个参数是自身类的类型引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</strong>拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非<code>const</code>引用的拷贝构造函数，但此参数几乎总是一个<code>const</code>引用。<strong>拷贝构造函数在几种情况下都会被隐式使用，因此拷贝构造函数通常不应该是<code>explicit</code>的。</strong></p>
<h3 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h3><p>​	如果我们没有为类定义拷贝构造函数，编译器会为我们定义一个。<strong>与合成默认构造函数不同，即使我们定义了其它构造函数，编译器也会为我们合成一个拷贝构造函数。</strong></p>
<p>​	合成拷贝构造函数用来阻止我们拷贝该类类型的对象，一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。<strong>编译器从给定对象中依次将每个非静态成员拷贝到正在创建的对象中。</strong></p>
<p>​	每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。</p>
<h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;           <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;                <span class="comment">// 直接初始化</span></span><br><span class="line">string s2 = dots;              <span class="comment">// 拷贝初始化</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>; <span class="comment">// 拷贝初始化</span></span><br><span class="line">string nines = <span class="built_in">string</span>(<span class="number">100</span>, <span class="string">&#x27;9&#x27;</span>);    <span class="comment">// 拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；而当我们使用拷贝初始化时，我们要求编译器将右侧运算符i下拷贝到正在创建的对象中。</strong></p>
<p>​	拷贝初始化通常由拷贝构造函数来完成，但是有时也会使用移动构造函数。拷贝初始化不仅在我们用<code>=</code>定义时会发生：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参；</li>
<li>从一个返回类型为非引用类型的函数返回一个对象；</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员；</li>
</ul>
<h3 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h3><p>​	在函数调用过程中，具有非引用类型的参数要进行拷贝初始化；类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p>
<p>​	<strong>拷贝构造函数被用来初始化非引用类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。</strong>如果不是引用类型，那么调用将会无限循环。</p>
<h3 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h3><p>​	拷贝初始化要求“隐式可转换”，而 <code>explicit</code> 构造函数禁止隐式转换，因此只能用于直接初始化。</p>
<h3 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h3><p>​	拷贝初始化过程中，编译器可以跳过拷贝&#x2F;移动构造函数，直接创建对象。</p>
<h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><p>​	与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，那么编译器会为其合成一个。</p>
<h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><p>​	重载运算符本质上是函数，其名字由<code>operator</code>关键字后接表示要定义的运算符的符号组成。因此赋值运算符就是一个名为<code>operator=</code>的函数。</p>
<p>​	重载运算符的参数表示运算符的运算对象，某些运算符，包括赋值运算符，必须定义为成员函数，如果一个运算符是一个成员函数，其左侧运算符就绑定到隐式的<code>this</code>参数。对于一个二元运算符，其右侧运算对象作为显式参数传递。</p>
<p>​	<strong>为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</strong></p>
<blockquote>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</blockquote>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>​	析构函数执行与构造函数相反的操作：构造函数初始化对象的非静态数据成员，还可能做一些其它操作（释放对象使用的资源，销毁对象的非静态数据成员）。</p>
<p>​	析构函数是类的成员函数，通常由波浪号接类名构成其名字。其没有返回值也不接受参数。</p>
<h3 id="析构函数完成什么工作"><a href="#析构函数完成什么工作" class="headerlink" title="析构函数完成什么工作"></a>析构函数完成什么工作</h3><p>​	在析构函数中，首先执行函数体，然后销毁成员，<strong>成员按初始化顺序的逆序销毁</strong>。通常，析构函数释放对象在生存期分配的所有资源。在一个析构函数中，不存在类似构造函数中初始化列表的东西控制成员如何销毁，析构函数是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<blockquote>
<p>隐式销毁一个内置指针类型的成员不会<code>delete</code>它所指向的对象。</p>
</blockquote>
<h3 id="什么时候调用析构函数"><a href="#什么时候调用析构函数" class="headerlink" title="什么时候调用析构函数"></a>什么时候调用析构函数</h3><p>​	无论何时，一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁；</li>
<li>当一个对象被销毁时，其成员被销毁；</li>
<li>容器被销毁时，其元素被销毁；</li>
<li>对于动态分配的对象，当对指向它的指针应用<code>delete</code>运算符时被销毁；</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁；</li>
</ul>
<p>​	由于析构函数自动运行，我们的程序可以按照需要分配资源，而通常无须担心何时释放资源。</p>
<blockquote>
<p>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
</blockquote>
<h3 id="合成析构函数"><a href="#合成析构函数" class="headerlink" title="合成析构函数"></a>合成析构函数</h3><p>​	当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。<strong>析构函数体自身并不直接销毁成员</strong>！成员是在析构函数体之后隐含的析构阶段中被销毁的。</p>
<h2 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h2><p>​	我们有三个基本操作控制类的拷贝操作；新标准下，我们还可以定义移动构造函数和一个移动赋值运算符。<code>C++</code>并不要求我们定义所有这些操作，可以只定义其中一个或两个，而不必定义所有。但是这些操作应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。</p>
<h3 id="需要析构函数的类也需要拷贝和赋值操作"><a href="#需要析构函数的类也需要拷贝和赋值操作" class="headerlink" title="需要析构函数的类也需要拷贝和赋值操作"></a>需要析构函数的类也需要拷贝和赋值操作</h3><p>​	<strong>当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求，要比对拷贝构造函数或赋值运算符的需求更为明显。</strong>如果这个类需要一个析构函数，那么它基本就需要一个拷贝构造函数和拷贝赋值运算符。</p>
<blockquote>
<p>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。</p>
</blockquote>
<h3 id="需要拷贝操作的类也需要赋值操作，反之亦然"><a href="#需要拷贝操作的类也需要赋值操作，反之亦然" class="headerlink" title="需要拷贝操作的类也需要赋值操作，反之亦然"></a>需要拷贝操作的类也需要赋值操作，反之亦然</h3><p>​	如果一个类需要一个拷贝构造函数，则它也需要一个拷贝赋值运算符，反之亦然。</p>
<h2 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h2><p>​	我们可以通过将拷贝控制成员定义为<code>default</code>来显式要求编译器生成合成版本。当我们在类内用<code>=default</code>修饰成员的声明时，合成的函数将隐式声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用<code>=default</code>，就像对拷贝赋值运算符所做的那样。</p>
<blockquote>
<p>我们只能对具有合成版本的成员函数使用<code>=default</code>。</p>
</blockquote>
<h2 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h2><blockquote>
<p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论隐式地还是显式地。</p>
</blockquote>
<p>​	虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。</p>
<h3 id="定义删除的函数"><a href="#定义删除的函数" class="headerlink" title="定义删除的函数"></a>定义删除的函数</h3><p>​	在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样的：我们虽然声明了它们，但不能以任何方式使用它们。在函数参数列表后面加上<code>=delete</code>来指出我们希望将它定义为删除的。</p>
<p>​	与<code>=default</code>不同的是，我们只能在函数第一次声明时<code>=delete</code>。另一个不同之处时，我们可以对任何函数指定<code>=delete</code>。</p>
<h3 id="析构函数不能是删除的成员"><a href="#析构函数不能是删除的成员" class="headerlink" title="析构函数不能是删除的成员"></a>析构函数不能是删除的成员</h3><p>​	值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。</p>
<p>​	对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象，但是不能释放这种对象。</p>
<blockquote>
<p>对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。</p>
</blockquote>
<h3 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a>合成的拷贝控制成员可能是删除的</h3><p>​	对某些类来说，编译器将这些合成的成员定义为删除的函数：</p>
<ul>
<li><strong>如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的。</strong></li>
<li><strong>如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</strong></li>
<li><strong>如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个<code>const</code>的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。</strong></li>
<li><strong>如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个<code>const</code>成员，它没有类内初始化器，且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</strong></li>
</ul>
<p>​	本质上这些规则的含义是：<strong>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</strong></p>
<blockquote>
<p>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p>
</blockquote>
<h3 id="private拷贝控制"><a href="#private拷贝控制" class="headerlink" title="private拷贝控制"></a><code>private</code>拷贝控制</h3><p>​	在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为<code>private</code>来阻止拷贝。若如此做，用户代码将不能拷贝这个类型的对象，但友元和成员函数仍旧可以拷贝对象，为<strong>了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明但不定义。</strong></p>
<p>​	声明但不定义一个成员函数是合法的，对此只有一个例外，后续将会介绍。</p>
<blockquote>
<p>希望阻止拷贝的类应该使用<code>=delete</code>来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为<code>private</code>。</p>
</blockquote>
<hr>
<h1 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h1><p>​	通常，<strong>管理类外资源的类必须定义拷贝控制成员</strong>。这种类需要析构函数来释放分配资源，因此按照之前的原则，我们几乎肯定要拷贝构造函数和拷贝赋值运算符。为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，我们有两种选择：<strong>可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</strong></p>
<p>​	类的行为像一个值，意味着它应该也有自己的状态，当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响；而如果像一个指针，则将会共享状态。</p>
<h2 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h2><p>​	<strong>为了提供类值行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</strong>为了实现类值行为，<code>HasPtr</code>需要：</p>
<ul>
<li>定义一个拷贝构造函数，完成成员的拷贝，而不是拷贝指针；</li>
<li>定义一个析构函数；</li>
<li>定义一个拷贝赋值运算符来释放对象的当前成员，并从右侧运算对象拷贝其成员。</li>
</ul>
<h3 id="类值拷贝赋值运算符"><a href="#类值拷贝赋值运算符" class="headerlink" title="类值拷贝赋值运算符"></a>类值拷贝赋值运算符</h3><p>​	<strong>赋值运算符通常组合了析构函数和构造函数的操作</strong>。一般来说，我们需要保证赋值运算符操作是按照正确顺序执行，且还是异常安全的——异常发生时，能够将左侧运算对象置于一个有意义的状态。</p>
<blockquote>
<p>当你编写赋值运算符时，需要记住两点：</p>
<ul>
<li>自赋值需要正确运行；</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作；</li>
</ul>
<p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象，拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
</blockquote>
<h2 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h2><p>​	对于行为像指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的<code>string</code>。我们的类仍然需要自己的析构函数来释放接受<code>string</code>参数的构造函数分配的内存。</p>
<p>​	令一个类展现类似指针的行为的最好办法是**使用<code>shared_ptr</code>**来管理类内资源。但是，有时我们希望直接管理资源，这种情况下，我们需要使用引用计数。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>​	引用计数工作方式如下：</p>
<ul>
<li><strong>除了初始化对象外，每个构造函数还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态；</strong></li>
<li><strong>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计时器；拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享；</strong></li>
<li><strong>析构函数递减计数器，如果计数器变为0，则析构函数释放状态；</strong></li>
<li><strong>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象计数器变为0，意味着它共享状态没有成员了，拷贝赋值运算符就必须销毁状态。</strong></li>
</ul>
<hr>
<h1 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h1><p>​	除了定义拷贝控制成员，管理资源的类通常还定义了一个名为<code>swap</code>的函数。如果一个类定义了自己的<code>swap</code>，那么算法将使用类自定义版本，否则算法将使用标准库定义的<code>swap</code>。</p>
<h2 id="编写我们自己的swap函数"><a href="#编写我们自己的swap函数" class="headerlink" title="编写我们自己的swap函数"></a>编写我们自己的<code>swap</code>函数</h2><p>​	我们可以在自己的类上定义自己版本的<code>swap</code>重载<code>swap</code>默认行为。与拷贝控制成员不同，<code>swap</code>并不是必须的，但是对于那些分配了资源的类来说，定义<code>swap</code>是一种很重要的优化手段。</p>
<h2 id="swap函数应该调用swap而不是std-swap"><a href="#swap函数应该调用swap而不是std-swap" class="headerlink" title="swap函数应该调用swap而不是std::swap"></a><code>swap</code>函数应该调用<code>swap</code>而不是<code>std::swap</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ps, rhs.ps);   <span class="comment">// 交换指针，而不是 string 数据</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.i, rhs.i);     <span class="comment">// 交换 int 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述代码最为微妙的地方在于：<code>using std::swap</code>。当我们定义它以后，每个<code>swap</code>调用都是未加限定的，每个调用都应该是<code>swap</code>而非<code>std::swap</code>，如果存在类型特定的<code>swap</code>版本，其匹配程度会优于<code>std</code>中定义的版本。如果不存在则会调用<code>std::swap</code>版本。</p>
<h3 id="在赋值运算符中使用swap"><a href="#在赋值运算符中使用swap" class="headerlink" title="在赋值运算符中使用swap"></a>在赋值运算符中使用<code>swap</code></h3><p>​	定义<code>swap</code>的类通常用<code>swap</code>来定义它们的赋值运算符。这些运算符将使用一个名为拷贝并交换的技术。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>注意参数并非引用类型</strong>。当赋值运算符结束时，<code>rhs</code>被销毁，<code>HasPtr</code>析构函数将执行。<strong>这个技术自动处理了自赋值情况，且天然就是异常安全的。</strong></p>
<hr>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>​	本章提供了两个示例类，在次不做赘述，可以浏览<code>C++ Primer</code> 13.4-13.5节查看。</p>
<hr>
<h1 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h1><p>​	新标准的最主要的特性之一是可以移动而非拷贝。在某些情况下，我们进行对象拷贝后，就立即销毁对象，在这些情况下，移动而非拷贝将大大提升性能。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>​	为了支持移动操作，新标准引入了新的引用类型：<strong>右值引用</strong>。<strong>所谓右值引用就是必须绑定到右值的引用</strong>。我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用。右值引用有一个重要性质：只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。</p>
<p>​	类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。对于常规引用，我们不能将其绑定到要求转换的表达式、字面值常量或是返回右值的表达式。右值引用有着完全相反的绑定特性，我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用绑定到一个左值上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r = i; <span class="comment">// 错误：不能将一个右值引用绑定到左值上</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i*<span class="number">42</span>; <span class="comment">// 错误：i*42是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = i * <span class="number">42</span>; <span class="comment">// 正确，我们可以将一个const引用绑定到一个右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>; <span class="comment">// 正确，我们可以将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>返回左值引用的函数，连同赋值、下标、解引用和前置递增&#x2F;递减运算符，都是返回左值的表达式的例子。</strong>我们可以将一个左值引用绑定到这类表达式的结果上。<strong>返回非引用类型的函数，连同算术、关系、位以及后置递增&#x2F;递减运算符，都会生成右值。</strong>我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个<code>const</code>的左值引用或者一个右值引用绑定到这类表达式上。</p>
<h3 id="左值持久，右值短暂"><a href="#左值持久，右值短暂" class="headerlink" title="左值持久，右值短暂"></a>左值持久，右值短暂</h3><p>​	考察左值和右值表达式的列表，两者互相区别的地方就很明显了：左值拥有持久的状态，而右值要么是字母常量要么是在表达式求值过程中创建的临时变量。</p>
<p>​	由于右值引用智能绑定到临时对象，我们得知：</p>
<ul>
<li>所引用的对象将要被销毁；</li>
<li>该对象没有其它用户；</li>
</ul>
<p>​	这两个特性意味着：使用右值引用的代码可以自由接管所引用对象的资源。</p>
<h3 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h3><p>​	<strong>变量可以看作只有一个运算对象而没有运算符的表达式</strong>。因为变量表达式都是左值，因此右值引用也是左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr2;  <span class="comment">// 错误！rr1是左值！</span></span><br></pre></td></tr></table></figure>

<h3 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库<code>move</code>函数</h3><p>​	虽然我们不能将一个右值引用直接绑定到一个左值，但我们可以显式将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<code>move</code>的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>

<p><code>move</code>调用通知编译器，我们有一个左值，但是我们希望像一个右值一样处理它，我们必须认识到，调用了<code>move</code>就意味着承诺：除了对<code>rr1</code>赋值或销毁它外，我们将不再使用它。在调用<code>move</code>后，我们不能对移动后源对象的值做任何假设。<strong>我们可以销毁一个移动后源对象，也可以赋予它新值，但是不能使用一个移动后源对象的值。</strong></p>
<blockquote>
<p>使用<code>move</code>的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p>
</blockquote>
<h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><p>​	如果我们自己的类同时支持移动和拷贝，那么我们也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员和拷贝控制的区别在于：<strong>它们窃取资源而非拷贝资源</strong>。</p>
<p>​	类似拷贝构造函数，<strong>移动构造函数的第一个参数是该类类型的一个引用</strong>。不同于拷贝构造函数，<strong>这个引用参数是一个右值引用</strong>。任何额外参数都必须有一个默认实参。</p>
<p>​	除了完成资源移动外，移动构造函数还必须确保移动后源对象处于销毁它是无害的状态。一旦资源移动完成，源对象必须不再指向被移动到资源，这些资源的所有权已经归属新创建的对象。</p>
<p>​	<strong>与拷贝构造函数不同的是，移动构造函数不分配任何新内存：它接管给定对象的内存。</strong></p>
<h3 id="移动操作、标准库容器和异常"><a href="#移动操作、标准库容器和异常" class="headerlink" title="移动操作、标准库容器和异常"></a>移动操作、标准库容器和异常</h3><p>​	<strong>由于移动操作窃取资源，它通常不分配任何资源。</strong>因此移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>
<p>​	一种通知标准库的方法是在我们的构造函数中指明<code>noexcept</code>。<code>noexcept</code>是新标准引入的，目前重要的是直到，<code>noexcept</code>是我们承诺一个函数不抛出异常的一种方法。我们必须在类头文件的声明中和定义中都指定<code>noexcept</code>。</p>
<blockquote>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p>
</blockquote>
<p>​	我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：<strong>首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身行为提供保障</strong>。</p>
<p>​	移动一个对象通常会改变它的值，如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间的移动源元素以及被改变了，而新空间中未构造的元素可能尚不存在，在此情况下，<code>vector</code>将不能满足自身保持不变的要求。</p>
<p>​	另一方面，如果<code>vector</code>使用了拷贝构造函数且发生了异常，它可以很容易满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生异常，<code>vector</code>可以释放新分配的内存并返回，原有的元素仍然存在。</p>
<p>​	为了避免潜在问题，除非<code>vector</code>知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望在<code>vector</code>重新分配内存这类情况下，对我们自定义类型的对象进行移动而不是拷贝，就必须显式告诉标准库我们的移动构造函数可以安全使用。通过将移动构造函数标记为<code>noexcept</code>来做到这一点。</p>
<h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><p>​	移动赋值运算符执行与析构函数和移动构造函数相同的工作。如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。移动赋值运算符也必须正确处理自赋值。</p>
<h3 id="移后源对象必须可析构"><a href="#移后源对象必须可析构" class="headerlink" title="移后源对象必须可析构"></a>移后源对象必须可析构</h3><p>​	<strong>在移动操作后，移动后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</strong></p>
<h3 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h3><p>​	与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是合成移动操作的条件与合成拷贝操作的条件大不相同。拷贝操作要么被定义为逐成员拷贝，要么被定义为为对象赋值，要么被定义为删除的函数。编译器不会为某些类合成移动操作，一旦一个类定义了自己的拷贝构造函数和拷贝赋值函数、析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。</p>
<p>​	<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非静态成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</strong></p>
<p>​	与拷贝操作不同，<strong>移动操作永远不会隐式定义为删除的函数</strong>。但是如果我们把移动操作显式定义为<code>=default</code>，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝构造操作类似的原则：</p>
<ul>
<li>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符类似。</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</li>
<li>类似拷贝赋值运算符，如果有类成员是<code>const</code>或是引用，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<p>​	移动操作和合成的拷贝控制成员还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响，<strong>如果类定义了一个移动构造函数和&#x2F;或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</strong></p>
<h3 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h3><p>​	如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用默认的函数匹配规则来决定使用哪个构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;  <span class="comment">// 左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;  <span class="comment">// 返回一个右值</span></span><br><span class="line">v2 = <span class="built_in">getVec</span>(cin);  <span class="comment">// 使用移动赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="但如果没有移动构造函数，右值也被拷贝"><a href="#但如果没有移动构造函数，右值也被拷贝" class="headerlink" title="但如果没有移动构造函数，右值也被拷贝"></a>但如果没有移动构造函数，右值也被拷贝</h3><p>​	如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过<code>move</code>来移动它们时也是如此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;); </span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;         <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(move(x))</span></span>;   <span class="comment">// 因为未定义移动构造，仍然调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>​	用拷贝构造函数代替移动构造函数几乎肯定是安全的，一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变原来对象的值。</p>
<h3 id="拷贝并交换赋值运算符和移动操作"><a href="#拷贝并交换赋值运算符和移动操作" class="headerlink" title="拷贝并交换赋值运算符和移动操作"></a>拷贝并交换赋值运算符和移动操作</h3><p>​	我们的<code>HasPtr</code>版本定义了一个拷贝并交换赋值运算符，它是函数匹配和移动操作间相互关系的很好示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i) &#123;p.ps=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 既是移动赋值运算符也是拷贝赋值运算符</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)&#123;<span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>建议：更新三&#x2F;五法则</strong></p>
<p>​	所有五个拷贝控制成员应该看作一个整体：<strong>一般来说，如果一个类定义了任何一个拷贝操作，他就应该定义所有五个操作</strong>。</p>
</blockquote>
<h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>​	新标准库中定义了一种移动迭代器适配器，一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个执行那个元素的左值，与其它迭代器不同，<strong>移动迭代器的解引用运算符生成一个右值引用</strong>。</p>
<p>​	我们通过调用标准库的<code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。</p>
<blockquote>
<p>建议：不要随意使用移动操作</p>
<p>​	<strong>在移动构造函数以及移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用<code>std::move</code>。</strong></p>
</blockquote>
<h2 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h2><p>​	除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。例如，定义了<code>push_back</code>的标准库容器提供两个版本，一个版本有一个右值引用参数，而另一个版本有一个<code>const</code>左值引用。</p>
<p>​	一般来说，我们不需要为函数操作定义接受一个<code>const X&amp;&amp;</code>或是一个<code>X&amp;</code>参数的版本。当我们希望从实参窃取数据时，通常传递一个右值引用，为了达到这一目的，实参不能是<code>const</code>的。类似的，从一个对象进行拷贝的操作不应该改变该对象，因此，通常不需要定义一个接受一个普通<code>X&amp;</code>参数的版本。</p>
<h3 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h3><p>​	旧标准中，我们没有办法阻止类似如下的右值调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + s2 = <span class="string">&quot;wow&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​	新标准中，我们可以指出<code>this</code>的左值&#x2F;右值属性，在参数列表后放置一个引用限定符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	引用限定符可以是<code>&amp;</code>&#x2F;<code>&amp;&amp;</code>，分别指出<code>this</code>可以指向一个左值或右值。类似<code>const</code>限定符，引用限定符只能用于非静态成员函数，且必须同时出现在函数的声明和定义中。<strong>一个函数可以同时用<code>const</code>和引用限定，引用限定符必须跟随在<code>const</code>限定符之后</strong>。</p>
<h3 id="重载和引用函数"><a href="#重载和引用函数" class="headerlink" title="重载和引用函数"></a>重载和引用函数</h3><p>​	我们同样可以用引用限定符区分重载版本。如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/26/CppPrimer/CppPrimer-12/">https://pomelover.github.io/2025/12/26/CppPrimer/CppPrimer-12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++ Primer</a><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img class="cover" src="/images/EffectiveC++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">(五)：实现</div></div></div></a><a class="pagination-related  no-desc" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第十二章：动态内存</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">第十五章：面向对象程序设计</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-28</div><div class="info-item-2">第十四章：重载运算与类型转换</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">第十二章：动态内存</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">第十一章：关联容器</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/20/CppPrimer/CppPrimer-09/" title="第十章：泛型算法"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">第十章：泛型算法</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">第九章：顺序容器</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">拷贝控制 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">2.</span> <span class="toc-text">拷贝、赋值与销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">合成拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">拷贝初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text">参数和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">2.1.4.</span> <span class="toc-text">拷贝初始化的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.5.</span> <span class="toc-text">编译器可以绕过拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">拷贝赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">重载赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.3.1.</span> <span class="toc-text">析构函数完成什么工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">什么时候调用析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">合成析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">2.4.</span> <span class="toc-text">三&#x2F;五法则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E4%B9%9F%E9%9C%80%E8%A6%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.1.</span> <span class="toc-text">需要析构函数的类也需要拷贝和赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E4%B9%9F%E9%9C%80%E8%A6%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%BA%A6%E7%84%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">需要拷贝操作的类也需要赋值操作，反之亦然</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-default"><span class="toc-number">2.5.</span> <span class="toc-text">使用&#x3D;default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.6.</span> <span class="toc-text">阻止拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">定义删除的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E5%88%A0%E9%99%A4%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">析构函数不能是删除的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E5%8F%AF%E8%83%BD%E6%98%AF%E5%88%A0%E9%99%A4%E7%9A%84"><span class="toc-number">2.6.3.</span> <span class="toc-text">合成的拷贝控制成员可能是删除的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">2.6.4.</span> <span class="toc-text">private拷贝控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">行为像值的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%80%BC%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">类值拷贝赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">定义行为像指针的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">引用计数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">交换操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">编写我们自己的swap函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E8%B0%83%E7%94%A8swap%E8%80%8C%E4%B8%8D%E6%98%AFstd-swap"><span class="toc-number">4.2.</span> <span class="toc-text">swap函数应该调用swap而不是std::swap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%AD%E4%BD%BF%E7%94%A8swap"><span class="toc-number">4.2.1.</span> <span class="toc-text">在赋值运算符中使用swap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">6.</span> <span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E6%8C%81%E4%B9%85%EF%BC%8C%E5%8F%B3%E5%80%BC%E7%9F%AD%E6%9A%82"><span class="toc-number">6.1.1.</span> <span class="toc-text">左值持久，右值短暂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%98%AF%E5%B7%A6%E5%80%BC"><span class="toc-number">6.1.2.</span> <span class="toc-text">变量是左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93move%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.</span> <span class="toc-text">标准库move函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">移动构造函数和移动赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.1.</span> <span class="toc-text">移动操作、标准库容器和异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.2.</span> <span class="toc-text">移动赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%90%8E%E6%BA%90%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E5%8F%AF%E6%9E%90%E6%9E%84"><span class="toc-number">6.2.3.</span> <span class="toc-text">移后源对象必须可析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.4.</span> <span class="toc-text">合成的移动操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%8F%B3%E5%80%BC%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%B7%A6%E5%80%BC"><span class="toc-number">6.2.5.</span> <span class="toc-text">移动右值，拷贝左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%86%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%B3%E5%80%BC%E4%B9%9F%E8%A2%AB%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.2.6.</span> <span class="toc-text">但如果没有移动构造函数，右值也被拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%B9%B6%E4%BA%A4%E6%8D%A2%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.7.</span> <span class="toc-text">拷贝并交换赋值运算符和移动操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.2.8.</span> <span class="toc-text">移动迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">右值引用和成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%92%8C%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">右值和左值引用成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">重载和引用函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十五章：面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计">第十五章：面向对象程序设计</a><time datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四章：重载运算与类型转换"/></a><div class="content"><a class="title" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换">第十四章：重载运算与类型转换</a><time datetime="2025-12-28T14:40:27.817Z" title="发表于 2025-12-28 22:40:27">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(五)：实现"/></a><div class="content"><a class="title" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现">(五)：实现</a><time datetime="2025-12-27T05:12:38.578Z" title="发表于 2025-12-27 13:12:38">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十三章：拷贝控制"/></a><div class="content"><a class="title" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制">第十三章：拷贝控制</a><time datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十二章：动态内存"/></a><div class="content"><a class="title" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存">第十二章：动态内存</a><time datetime="2025-12-22T12:49:57.719Z" title="发表于 2025-12-22 20:49:57">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>