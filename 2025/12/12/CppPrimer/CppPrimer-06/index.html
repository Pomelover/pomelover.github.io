<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第七章：类 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类 简介​	类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现的分离式编程。类的接口包括用户所能执行的操作，类的实现则包括类数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 ​	封装实现了类接口和实现的分离。封装后的类隐藏了它的实现细节，类要想实现数据抽象和封装，需要首先定义一个抽象数据类型。  定义抽象数据类型​	我们假设目前有如下定义的Sales_data类型： 1234">
<meta property="og:type" content="article">
<meta property="og:title" content="第七章：类">
<meta property="og:url" content="https://pomelover.github.io/2025/12/12/CppPrimer/CppPrimer-06/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="类 简介​	类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现的分离式编程。类的接口包括用户所能执行的操作，类的实现则包括类数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 ​	封装实现了类接口和实现的分离。封装后的类隐藏了它的实现细节，类要想实现数据抽象和封装，需要首先定义一个抽象数据类型。  定义抽象数据类型​	我们假设目前有如下定义的Sales_data类型： 1234">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/cpp_logo.png">
<meta property="article:published_time" content="2025-12-11T16:30:54.778Z">
<meta property="article:modified_time" content="2025-12-13T07:24:16.341Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ Primer">
<meta property="article:tag" content="C++ 学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/cpp_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第七章：类",
  "url": "https://pomelover.github.io/2025/12/12/CppPrimer/CppPrimer-06/",
  "image": "https://pomelover.github.io/images/cpp_logo.png",
  "datePublished": "2025-12-11T16:30:54.778Z",
  "dateModified": "2025-12-13T07:24:16.341Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/12/CppPrimer/CppPrimer-06/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第七章：类',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">第七章：类</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">第七章：类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-11T16:30:54.778Z" title="发表于 2025-12-12 00:30:54">2025-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-13T07:24:16.341Z" title="更新于 2025-12-13 15:24:16">2025-12-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="类-简介"><a href="#类-简介" class="headerlink" title="类 简介"></a>类 简介</h1><p>​	<strong>类的基本思想是数据抽象和封装</strong>。数据抽象是一种<strong>依赖于接口和实现的分离式编程</strong>。类的接口包括用户所能执行的操作，类的实现则包括类数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p>​	<strong>封装实现了类接口和实现的分离</strong>。封装后的类隐藏了它的实现细节，类要想实现数据抽象和封装，需要首先定义一个抽象数据类型。</p>
<hr>
<h1 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h1><p>​	我们假设目前有如下定义的<code>Sales_data</code>类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	但上述<code>Sales_data</code>类不是一个抽象数据类型，它允许类的用户直接访问它的数据成员。</p>
<h2 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计<code>Sales_data</code>类</h2><p>​	我们的最终目的是令<code>Sales_data</code>支持与<code>Sales_item</code>类完全一样的操作集合。</p>
<p>​	因为我们跳过了部分内容，在此我直接进行总结，<code>Sales_data</code>的接口应该包含以下操作：</p>
<ul>
<li>一个<code>isbn</code>成员函数，用于返回对象的ISBN编号；</li>
<li>一个<code>combine</code>成员函数，用于将一个<code>Sales_data</code>对象加到另一个对象上；</li>
<li>一个名为<code>add</code>的函数，执行两个<code>Sales_data</code>对象的加法；</li>
<li>一个名为<code>read</code>的函数，将数据从<code>istream</code>读入到<code>Sales_data</code>对象中；</li>
<li>一个名为<code>print</code>的函数，将<code>Sales_data</code>对象的值输出到<code>ostream</code>;</li>
</ul>
<blockquote>
<p>关键概念：不同的编程角色</p>
<p>​	程序员常把运行其程序的人称作用户。类的设计者也是为其用户设计并实现一个类的人；类的用户是程序员，而非应用程序的最终使用者。</p>
<p>​	<code>C++</code>程序员无须刻意区分应用程序的用户以及类的用户。</p>
</blockquote>
<h2 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的<code>Sales_data</code>类</h2><p>​	如前所述，我们的<code>Sales_data</code>将类似如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员接口函数</span></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义在类内部的函数是隐式的<code>inline</code>函数。</p>
</blockquote>
<h3 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h3><p>​	尽管所有成员都必须在类的内部声明，但是成员函数的定义可以在类内也可以定义在类外。</p>
<h3 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入<code>this</code></h3><p>​	我们来观察<code>isbn</code>成员函数的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br></pre></td></tr></table></figure>

<p>​	我们使用了点运算符来访问<code>total</code>对象的<code>isbn</code>成员，然后调用它。成员函数通过一个名为<code>this</code>的额外隐式函数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>。例如我们调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br></pre></td></tr></table></figure>

<p>​	则编译器负责把<code>total</code>的地址传递给<code>isbn</code>的隐式形参<code>this</code>，可以等价认为编译器将该调用重写成了如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br></pre></td></tr></table></figure>

<p>​	因为<code>this</code>的目的总是指向这个对象，所以<code>this</code>是一个常量指针。</p>
<h3 id="引入const成员函数"><a href="#引入const成员函数" class="headerlink" title="引入const成员函数"></a>引入<code>const</code>成员函数</h3><p>​	<code>isbn</code>的另一个关键之处是紧随参数列表之后的<code>const</code>关键字，这里<code>const</code>的作用是修饰<code>this</code>指针的类型。</p>
<p>​	默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。例如在<code>Sales_data</code>成员函数中，<code>this</code>的类型是<code>Sales_data* const</code>。默认情况下，我们不能把<code>this</code>绑定到一个常量对象上。因此，将<code>this</code>设置为指向常量的指针有助于提高函数的灵活性。</p>
<p>​	<code>C++</code>语言允许把<code>const</code>关键字放在参数列表后，此时，表示<code>this</code>是一个指向常量的指针，这样使用<code>const</code>修饰的成员函数称为常量成员函数。</p>
<blockquote>
<p>常量对象与常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<h3 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h3><p>​	类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域内，因此<code>isbn</code>中用到的名字<code>bookNo</code>其实就是定义在<code>Sales_data</code>内的数据成员。</p>
<p>​	值得注意的是，即使<code>bookNo</code>定义在<code>isbn</code>之后，<code>isbn</code>也还是能够使用<code>bookNo</code>。编译器分两步处理类：<strong>首先编译成员的声明，然后才轮到成员函数体。</strong></p>
<h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><p>​	当我们在类外部定义成员函数时，成员函数的定义必须与它的声明匹配（包括<code>const</code>成员函数属性）。</p>
<h3 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回<code>this</code>对象的函数</h3><p>​	函数<code>combine</code>的设计初衷类似于复合赋值运算符<code>+=</code>，调用该函数的对象代表的是赋值运算符左侧运算对象，右侧运算对象则通过实参传入函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> string&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold+=rhs.units_sold;</span><br><span class="line">    revenue+=rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是该函数的返回类型与返回语句。内置的赋值运算符将左侧运算对象当成左值返回，为了保持一致，<code>combine</code>函数必须返回引用类型。</p>
<h2 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h2><blockquote>
<p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p>
</blockquote>
<h3 id="定义read和print函数"><a href="#定义read和print函数" class="headerlink" title="定义read和print函数"></a>定义<code>read</code>和<code>print</code>函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">    item.revenue=price*item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">read</span><span class="params">(ostream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>read</code>和<code>print</code>各自接受一个<code>IO</code>类型的引用作为其参数，因为<code>IO</code>类不能被拷贝。同时，读取与写入会修改流的内容，因此其不是常量引用。</p>
<p>​	同时<code>print</code>函数不应进行换行，格式控制应尽量由用户控制。</p>
<h3 id="定义add函数"><a href="#定义add函数" class="headerlink" title="定义add函数"></a>定义<code>add</code>函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>​	每个类分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数称为<strong>构造函数</strong>。构造函数的任务是初始化类对象的数据成员，无论何时只要类对象被创建，就会执行构造函数。</p>
<p>​	构造函数的名字和类名相同，和其它函数不一样的是，构造函数没有返回类型；除此之外类似于其它的函数，构造函数也有一个参数列表和一个函数体。不同于其它成员函数，构造函数不能被声明成<code>const</code>，当我们构造一个<code>const</code>对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。</p>
<h3 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h3><p>​	类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做<strong>默认构造函数</strong>，默认构造函数无须任何实参。<strong>如果我们的类没有显式定义构造函数，那么编译器就会为我们隐式定义一个默认构造函数。</strong>编译器提供的默认构造函数又称为合成的默认构造函数，对于大多数类来说，其按照如下规则默认初始化类的数据成员：</p>
<ul>
<li>如果存在类内的初始值，用它来初始化成员；</li>
<li>否则，默认初始化该成员；</li>
</ul>
<h3 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h3><p>​	<strong>合成的默认构造函数只能适合非常简单的类。</strong>一般来说，一个普通的类必须定义它自己的默认构造函数，原因如下：</p>
<ol>
<li>编译器只有在发现类不包含任何构造函数时才会创建一个默认的构造函数，<strong>因此一旦我们定义了一些其它构造函数，那么除非我们再定义一个默认构造函数，否则类将没有默认构造函数；</strong></li>
<li>对某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在某些块中的内置类型或复合类型的对象被默认初始化，则它们的值将会是未定义的。</li>
<li>有时候，编译器不能为某些类合成默认的构造函数，例如：如果类中包含一个其它类的成员，但是这个类没有默认构造函数，那么编译器无法初始化该成员。</li>
</ol>
<p>​	在<code>C++11</code>标准中，如果我们需要默认的行为，那么就可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数。和其它函数一样，如果<code>=default</code>在类的内部，则默认构造函数是内联的，如果在外部，默认情况下不是内联的。</p>
<h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>​	我们可以通过如下形式书写构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string&amp; s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	其中冒号以及冒号与花括号之间的代码称之为构造函数初始值列表，它负责为新创建的对象数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值，不同成员的初始化通过逗号分割开来。</p>
<blockquote>
<p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同，如果你不能使用类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。</p>
</blockquote>
<h3 id="在类的外部定义构造函数"><a href="#在类的外部定义构造函数" class="headerlink" title="在类的外部定义构造函数"></a>在类的外部定义构造函数</h3><p>​	构造函数没有返回类型，我们在类外部定义构造函数时，必须指明该构造函数是那个类的成员。没有出现在构造函数初始值列表中的成员将通过相应的类内初始值初始化，或者执行默认初始化。这意味着，函数开始执行，则<code>bookNo</code>被初始化为空串，而其它将被初始化为0。</p>
<h2 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h2><p>​	除了定义类的成员如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。</p>
<p>​	对象将会在几种情况下被拷贝，如初始化变量以及以值的方式传递或返回一个对象等。当我们使用了赋值运算符时会发生对象的赋值操作。当对象不再存在时执行销毁操作。</p>
<p>​	如果我们不主动定义这些操作，则编译器将替我们合成他们。</p>
<h3 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h3><p>​	同样，尽管编译器能够替我们合成拷贝、赋值和西沟操作，但是必须清楚：对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成版本将会失效。</p>
<hr>
<h1 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	到目前为止，我们已经为类定义了接口，但是没有机制强制用户使用这些接口。我们的类还没有封装，因此我们使用访问说明符加强类的封装性：</p>
<ul>
<li>定义在<code>public</code>说明符之后的成员在整个程序内可被访问，<code>public</code>成员定义类的接口；</li>
<li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问；</li>
</ul>
<p>​	再一次定义<code>Sales_data</code>类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s, <span class="type">unsigned</span> n, <span class="type">double</span> p);</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s);</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream&amp;);</span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="使用class或struct关键字"><a href="#使用class或struct关键字" class="headerlink" title="使用class或struct关键字"></a>使用<code>class</code>或<code>struct</code>关键字</h3><p>​	在上面的定义中，我们使用了<code>class</code>关键字而非<code>struct</code>开始类的定义，这种变化仅仅是形式上有所不同，实际上我们可以使用这两个关键字中的任何一个定义类。唯一的一点区别是，<code>struct</code>和<code>class</code>的默认访问权限不一样。</p>
<p>​	类可以在它的第一个说明访问符之前定义成员，对这种成员的访问权限依赖于类定义的方式，如果我们使用<code>struct</code>关键字，则定义在第一个访问说明符之前的成员是<code>public</code>；而<code>class</code>关键字这些成员是<code>private</code>。</p>
<blockquote>
<p>使用<code>class</code>和<code>struct</code>定义类的唯一区别就是默认访问权限。</p>
</blockquote>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>​	既然<code>Sales_data</code>的数据成员是<code>private</code>，则<code>read</code>&#x2F;<code>print</code>&#x2F;<code>add</code>函数就无法访问其非公有成员。如果想实现，我们可以通过<code>friend</code>关键词将成员声明为友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限制。友元不是类的成员也不受所在区域内访问控制级别的约束。</p>
<blockquote>
<p>一般来说，最好在类定义开始或结束前的位置集中声明友元。</p>
</blockquote>
<p>​	一般来说，封装有两个重要优点：</p>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态；</li>
<li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码；</li>
</ul>
<p>​	一旦把数据成员定义成<code>private</code>，类的作者就可以比较自由地修改数据了，当实现部分改变时，我们只需检查类的代码本身以确认这次改变有什么影响；换句话说，只要类的接口不变，用户代码就无需改变。如果数据是<code>public</code>的，则所有使用了原来数据成员的代码都可能失效。</p>
<p>​	把数据成员的访问限制设成<code>private</code>还有另外一个好处，能够防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。</p>
<h3 id="友元的声明"><a href="#友元的声明" class="headerlink" title="友元的声明"></a>友元的声明</h3><p>​	友元的声明仅仅指定了访问权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常对友元的声明与类本身放置在同一个头文件中。</p>
<blockquote>
<p>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。</p>
</blockquote>
<hr>
<h1 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h1><h2 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h2><h3 id="定义一个类型成员"><a href="#定义一个类型成员" class="headerlink" title="定义一个类型成员"></a>定义一个类型成员</h3><p>​	<code>Screen</code>表示显示器的一个窗口，每个<code>Screen</code>包含一个用于保存<code>Screen</code>内容的<code>string</code>成员和和三个<code>string::size_type</code>类型的成员，分别表示了光标的位置与屏幕宽高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width =<span class="number">0</span>;</span><br><span class="line">    string contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	用来定义类型的成员必须先定义后使用，因此类型成员一般在类开始的地方。</p>
<h3 id="Screen类的成员函数"><a href="#Screen类的成员函数" class="headerlink" title="Screen类的成员函数"></a><code>Screen</code>类的成员函数</h3><p>​	为了让类更加实用，我们添加构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c):<span class="built_in">height</span>(ht),<span class="built_in">width</span>(wd),<span class="built_in">contents</span>(ht*wd,c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> contents[cursor];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width =<span class="number">0</span>;</span><br><span class="line">    string contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h3><p>​	在类中，常有一些规模较小的函数适合于被声明为内联函数，定义在类内部的成员函数是自动内联的，在类的外部我们也可以用<code>inline</code>修饰函数的定义。</p>
<h3 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h3><p>​	和非成员函数一样，成员函数也可以被重载，只要函数的参数数量&#x2F;类型上有所区别即可。</p>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>​	有时我们希望能修改类的某个数据成员，即使在一个<code>const</code>成员函数内，此时我们可以在成员变量的声明中声明<code>mutable</code>关键字。一个可变数据成员永远不是<code>const</code>，即使它是<code>const</code>对象的成员。</p>
<h3 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h3><p>​	在定义好<code>Screen</code>类之后，我们继续定义一个窗口管理类并用它表示显示器上的一组<code>Screen</code>。这个类将包含一个<code>Screen</code>类型的<code>vector</code>。默认情况下，我们希望其在开始时拥有一个默认初始化的<code>Screen</code>，在<code>C++11</code>新标准中，最好的方式就是把这个默认值声明成一个类内初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowMgr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>,<span class="number">80</span>,<span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>类内初始值必须以赋值运算符或者花括号表示。</strong></p>
<h2 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回<code>*this</code>的成员函数</h2><p>​	接下来我们继续添加一些函数，它们负责设置光标所在位置的字符或者其它任一给定位置的字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	和<code>move</code>操作一样，我们的<code>set</code>返回值是调用<code>set</code>的对象的引用，返回引用的函数是左值的，意味着这些函数返回的是对象本身而非副本，因此如下两种语句是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>​	假如我们定义的返回类型不是引用，则行为则大相径庭，将不会改变<code>myScreen</code>的值。</p>
<h3 id="从const成员函数返回-this"><a href="#从const成员函数返回-this" class="headerlink" title="从const成员函数返回*this"></a>从<code>const</code>成员函数返回<code>*this</code></h3><p>​	有时候我们会在<code>const</code>成员函数中以引用形式返回<code>*this</code>，此时应把其返回类型声明成常量引用。</p>
<h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于<code>const</code>的重载</h3><p>​	通过区分成员函数是否是<code>const</code>，我们可以对其进行重载。具体来说，非常量版本的函数对于常量对象是不可用的，因此我们只能在一个常量对象上调用<code>const</code>成员函数，另一方面，在非常量对象上，调用非常量成员函数是一个更好的匹配。</p>
<blockquote>
<p>建议：对于公共代码使用私有功能函数</p>
<p>​	使用私有功能函数有以下好处：</p>
<ol>
<li>基本的愿望是避免在多处使用同样的代码；</li>
<li>在同一处实现同一功能更方便修改；</li>
<li>我们知道函数内部的函数定义是默认内联的，因此额外的函数调用不会增加任何开销。</li>
</ol>
</blockquote>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>​	每个类定义了唯一的类型，对于两个类来说，即使成员完全一样，这两个类也是不同的类型。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>​	就像可以把函数的声明和定义分离，我们也能仅仅声明类而暂时不定义它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;</span><br></pre></td></tr></table></figure>

<p>​	这种声明有时被称作<strong>前向声明</strong>，它向程序中引入名字<code>Screen</code>并且指明其是一种类类型，在它声明之后定义之前是一个不完全类型。对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。</p>
<p>​	有一种例外的情况：<strong>直到类被定义之后数据成员才能被声明成这种类类型。</strong>换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含其自身类型的引用或指针。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>​	我们不仅可以把函数在类中定义成友元，我们也能将其他类以及其他类的成员函数定义成友元。友元函数能定义在类的内部，这样的函数是隐式内联的。</p>
<h3 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h3><p>​	假设我们有一个类管理<code>Screen</code>，此时可能需要修改<code>Screen</code>的私有数据成员，此时我们可以通过将该类声明为友元类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ScreenMgr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。需要注意的是，友元关系不存在传递性。</p>
<blockquote>
<p>每个类负责控制自己的友元类或者友元函数</p>
</blockquote>
<h3 id="令成员函数作为友元"><a href="#令成员函数作为友元" class="headerlink" title="令成员函数作为友元"></a>令成员函数作为友元</h3><p>​	我们也可以把某些成员函数指定为其友元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> Screen:<span class="built_in">clear</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	要想令成员函数作为友元，我们需要仔细组织程序结构满足声明和定义的彼此依赖关系。</p>
<ul>
<li>首先定义<code>ScreenMgr</code>类，其中声明<code>clear</code>但不定义它。在<code>clear</code>使用<code>Screen</code>成员之前必须先声明<code>Screen</code>;</li>
<li>接下来定义<code>Screen</code>，包括对于<code>clear</code>友元声明；</li>
<li>最后定义<code>clear</code>，此时它才可以使用<code>Screen</code>成员；</li>
</ul>
<h3 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h3><p>​	尽管重载函数名字相同，但他们仍然是不同的函数，因此如果一个类想把一组重载函数声明成它的友元，需要对这组函数中的每一个分别声明。</p>
<h3 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h3><p>​	<strong>类和非成员函数的声明不是必须在它们的友元声明之前。</strong>当一个名字第一次出现在一个友元声明中时，我们隐式假定该名字在当前作用域中是可见的。然而友元本身不一定真的声明在当前作用域中。</p>
<p>​	甚至就算在类内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="comment">/* 定义 */</span>&#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>();&#125; <span class="comment">// 错误！f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>();&#125; <span class="comment">// 错误！f还没有被声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>();&#125; <span class="comment">// 正确，现在f的声明在作用域中</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>​	每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符来访问。</p>
<h3 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h3><p>​	一个类就是一个作用域。在类的外部，成员的名字被隐藏起来了。</p>
<p>​	一旦遇到了类名，定义的剩余部分就在类的作用域之内，这里的剩余部分包括参数列表和函数体。我们可以直接使用类的其它成员而无须再次授权了。</p>
<p>​	另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。</p>
<h2 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h2><p>​	目前为止，我们编写的程序中，名字查找的过程比较直截了当：</p>
<ul>
<li>首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明；</li>
<li>如果没找到，继续查找外层作用域；</li>
<li>如果最终没有找到匹配的声明，则程序报错；</li>
</ul>
<p>​	对于定义在类内部的成员函数来说，解析其中名字的方式与上述查找规则有所区别，类的定义分两步处理：</p>
<ul>
<li>首先编译成员的声明；</li>
<li>直到类全部可见后才编译函数体；</li>
</ul>
<blockquote>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
</blockquote>
<p>​	按照这种两段式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字，相反，如果函数的定义和成员的声明同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。</p>
<h3 id="用于类成员声明的名字查找"><a href="#用于类成员声明的名字查找" class="headerlink" title="用于类成员声明的名字查找"></a>用于类成员声明的名字查找</h3><p>​	这种两阶段的处理方式只适用于成员函数中使用的名字。<strong>声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。</strong>如果某个成员的声明使用了类中尚未出现的名字，则编译器会在类的作用域中继续查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	当编译器看到<code>balance</code>的声明语句中，它将在<code>Account</code>类的范围内寻找对<code>Money</code>的声明。编译器只考虑<code>Account</code>中在使用<code>Money</code>前出现的声明，因为没找到匹配的成员，所以编译器会接着到<code>Account</code>的外层作用域中查找。</p>
<p>​	另一方面，<code>balance</code>函数体在整个类可见后才处理，因此，该函数<code>return</code>返回的是名为<code>bal</code>成员。</p>
<h3 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h3><p>​	一般来说，内层作用域可以重新定义外层作用域中的名字，即便该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个成员，而该名字代表一种类型，则类不能在之后重新定义该名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> money;  <span class="comment">// 错误：不能重新定义Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p>
</blockquote>
<h3 id="成员定义中的普通块作用域的名字查找"><a href="#成员定义中的普通块作用域的名字查找" class="headerlink" title="成员定义中的普通块作用域的名字查找"></a>成员定义中的普通块作用域的名字查找</h3><p>​	成员函数中使用的名字按照如下方式解析：</p>
<ul>
<li>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑；</li>
<li>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑；</li>
<li>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</li>
</ul>
<p>​	一般来说，不建议使用其它成员的名字作为某个成员函数的参数。不过为了更好地解释名字的解析过程，我们不妨在<code>dummyFunc</code>函数中违反一下这个约定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该段代码并不是一段很好的代价</span></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummyFunc</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">        cursor = width * height;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	当编译器处理<code>dummyFunc</code>的乘法表达式时，它首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此<code>dummyFunc</code>函数体内用到的名字<code>height</code>指的是参数声明。</p>
<p>​	在此例中，<code>height</code>参数隐藏了同名的成员。如果能绕开上面的查找规则，应该将代码改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议的写法：成员函数中的名字不应该隐藏同名的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummyFunc</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;  <span class="comment">// 成员height</span></span><br><span class="line">    <span class="comment">// 另外一种表示该成员的方式</span></span><br><span class="line">    cursor = width * Screen::height; <span class="comment">// 成员height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用<code>this</code>指针来强制访问成员。</p>
</blockquote>
<p>​	其实最好的确保我们使用<code>height</code>成员的方法是给参数起个其他名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议的方法： 不要把成员名字作为参数或者其它局部变量使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummyFunc</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">    cursor = width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在此例中，当编译器查找名字<code>height</code>时，显然在<code>dummyFunc</code>函数内部是找到不到的。编译器接着会在<code>Screen</code>内查找匹配的声明，即使<code>height</code>的声明出现在<code>dummyFunc</code>使用它之后，编译器也能正确解析函数使用的是名为<code>height</code>的成员。</p>
<h3 id="类作用域之后，在外围的作用域中查找"><a href="#类作用域之后，在外围的作用域中查找" class="headerlink" title="类作用域之后，在外围的作用域中查找"></a>类作用域之后，在外围的作用域中查找</h3><p>​	如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。在我们的例子中，名字<code>height</code>定义在外层作用域中，且位于<code>Screen</code>定义之前。然而，外层作用域中的对象被名为<code>height</code>的成员隐藏掉了。因此，如果我们需要的是外层作用域中的名字，可以显式地通过作用域运算符来进行请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummyFunc</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * ::height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符运算符访问它。</p>
</blockquote>
<h3 id="在文件中名字的出现处对其进行解析"><a href="#在文件中名字的出现处对其进行解析" class="headerlink" title="在文件中名字的出现处对其进行解析"></a>在文件中名字的出现处对其进行解析</h3><p>​	当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(pos)</span></span>;</span><br><span class="line">    pos height = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Screen::pos <span class="title">verify</span><span class="params">(Screen::pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::setHeight</span><span class="params">(pos var)</span></span>&#123;</span><br><span class="line">    height = <span class="built_in">verify</span>(var);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	全局函数<code>verify</code>的声明在<code>Screen</code>类的定义之前是不可见的。然而，名字查找的第三步包括了成员函数出现之前的全局作用域。</p>
<hr>
<h1 id="构造函数再谈"><a href="#构造函数再谈" class="headerlink" title="构造函数再谈"></a>构造函数再谈</h1><p>​	对于任何<code>C++</code>的类来说，构造函数都是其中重要的组成部分。</p>
<h2 id="构造函数初始值列表-1"><a href="#构造函数初始值列表-1" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><p>​	当我们定义变量时，习惯于立即对其进行初始化，而非先定义、再赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string foo = <span class="string">&quot;Hello World!&quot;</span>;      <span class="comment">// 定义并初始化</span></span><br><span class="line">string bar;                       <span class="comment">// 默认初始化成空串</span></span><br><span class="line">bar = <span class="string">&quot;Hellow World!&quot;</span>;            <span class="comment">// 为bar赋新值</span></span><br></pre></td></tr></table></figure>

<p>​	就对象的数据成员而言，初始化和赋值也有类似的区别。<strong>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="type">const</span> sting&amp; s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price)&#123;</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = cnt;</span><br><span class="line">    revenue = cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这段代码对数据成员执行了赋值操作。因为它先执行默认初始化。</p>
<h3 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h3><p>​	有时我们可以忽略数据成员初始化和赋值之间的差异，但有时候我们无法忽略，比如成员是<code>const</code>胡总和引用，则我们必须先进行初始化！</p>
<blockquote>
<p>如果成员是<code>const</code>&#x2F;引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p>
<p><strong>建议：使用构造函数初始值</strong></p>
<p>​	很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化后赋值。</p>
</blockquote>
<h3 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h3><p>​	显然，在构造函数初始值中每个成员只能出现一次。不过让人意外的是，<strong>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</strong>成员初始化顺序与它们在类定义中的出现顺序一致：第一个初始值先被初始化，然后第二个，以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际初始化顺序。</strong></p>
<blockquote>
<p>最好令构造函数初始值的顺序与成员声明的顺序保持一致，而且如果可能的话，应该尽量避免使用某些成员初始化其它成员。</p>
</blockquote>
<h3 id="默认实参和构造函数"><a href="#默认实参和构造函数" class="headerlink" title="默认实参和构造函数"></a>默认实参和构造函数</h3><p>​	<code>Sales_data</code>默认构造函数的行为与只接受一个<code>string</code>实参的构造函数差不多。唯一的区别是接受<code>string</code>实参的构造函数使用这个实参初始化<code>bookNo</code>，而默认构造函数使用<code>string</code>的默认构造函数初始化<code>bookNo</code>。我们可以把它重写为一个使用默认实参的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s = <span class="string">&quot;&quot;</span>) : <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
</blockquote>
<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>​	<code>C++11</code>新标准扩展了构造函数初始值的功能，使得我们可以定义所谓<strong>委托构造函数</strong>。一个委托构造函数<strong>使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些职责委托给了其它构造函数。</strong></p>
<p>​	和其它构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。<strong>在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。</strong>和其它成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(): <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s): <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream&amp; is): <span class="built_in">Sales_data</span>() &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	在这个类中，除了一个构造函数外，其它的都委托了它们的工作。</p>
<h2 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h2><p>​	当对象被默认构造化，或值初始化自动默认构造函数。默认初始化在以下情况下发生：</p>
<ul>
<li>当我们在块作用域内不适用任何初始值定义一个非静态变量或者数组时；</li>
<li>当一个类本身含有类类型的成员且使用合成的默认构造函数时；</li>
<li>当类类型的成员没有在构造函数初始值列表中显式初始化时；</li>
</ul>
<p>​	值初始化在以下情况下发生：</p>
<ul>
<li>在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时；</li>
<li>当我们不适用初始值定义一个局部静态变量时；</li>
<li>当我们通过书写形如<code>T()</code>的表达式显式请求值初始化时，其中<code>T</code>是类型名；</li>
</ul>
<p>​	类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。不那么明显的一种情况是类的某些数据成员缺少默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefault</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">const</span> string&amp;);</span><br><span class="line">    <span class="comment">// 还有其它成员，但是没有其它构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line">A a;  <span class="comment">// 错误，不能为A合成构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>() &#123;&#125;  <span class="comment">// 错误，b_member没有初始值</span></span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实际中，如果定义了其它构造函数，那么最好也提供一个默认构造函数。</p>
</blockquote>
<h3 id="使用默认构造函数"><a href="#使用默认构造函数" class="headerlink" title="使用默认构造函数"></a>使用默认构造函数</h3><p>​	下面的<code>obj</code>声明可以正常编译通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>; <span class="comment">// 正确：定义了一个函数而非对象</span></span><br><span class="line"><span class="keyword">if</span>(obj.<span class="built_in">isbn</span>() == Primer_5th_ed.<span class="built_in">isbn</span>())  <span class="comment">// 错误：obj是一个函数</span></span><br></pre></td></tr></table></figure>

<p>​	但当我们试图使用<code>obj</code>时，编译器将报错，提示我们不能对函数使用成员访问运算符。问题在于，尽管我们想声明一个默认初始化的对象，<code>obj</code>实际的含义是一个不接受任何参数的函数并且其返回值是<code>Sales_data</code>类型的对象，如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data obj;</span><br></pre></td></tr></table></figure>

<h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><p>​	我们也能为类定义隐式转换机制，如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。</p>
<blockquote>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<p>​	在<code>Sales_data</code>类中，接受<code>string</code>的构造函数和接受<code>istream</code>构造函数分别定义了从这两种类型向<code>Sales_data</code>隐式转换的规则。</p>
<h3 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h3><p>​	<strong>编译器只会自动执行一步类型转换</strong>，例如下面的代码隐式使用两种转换规则，所以它是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br><span class="line"><span class="comment">// 错误：需要用户定义两种转换</span></span><br><span class="line"><span class="comment">// (1) 把&quot;9-999-99999-9&quot;转换成string</span></span><br><span class="line"><span class="comment">// (2) 再把这个string转换成Sales_data</span></span><br></pre></td></tr></table></figure>

<p>​	如果我们想完成上述调用，可以显式把字符串转换成<code>string</code>或<code>Sales_data</code>对象。</p>
<h3 id="类类型转换不是总有效"><a href="#类类型转换不是总有效" class="headerlink" title="类类型转换不是总有效"></a>类类型转换不是总有效</h3><p>​	是否需要从<code>string</code>到<code>Sales_data</code>的转换依赖于我们对用户使用该转换的看法。在此例中，这种转换可能是对的。<code>null_book</code>中的<code>string</code>可能表示了一个不存在的<code>ISBN</code>编号。</p>
<p>​	另一个是从<code>istream</code>到<code>Sales_data</code>的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(cin);</span><br></pre></td></tr></table></figure>

<p>​	这段代码隐式把<code>cin</code>转换成<code>Sales_data</code>，这个转换执行了接受一个<code>istream</code>的<code>Sales_data</code>构造函数，该构造函数通过读取标准输入创建了一个临时对象<code>Sales_data</code>，随后将得到的对象传递给函数。这个对象是一个临时之，一旦<code>combine</code>完成就不能再访问它了。</p>
<h3 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h3><p>​	在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为<code>explicit</code>加以阻止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string&amp; s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span>: bookNo(s) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(istream&amp;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	此时没有任何构造函数能用于隐式创建<code>Sales_data</code>对象，之前的两种用法无法通过编译。关键字<code>explicit</code>只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为<code>explicit</code>。只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外部定义时不应重复。</p>
<h3 id="explicit构造函数只能用于直接初始化"><a href="#explicit构造函数只能用于直接初始化" class="headerlink" title="explicit构造函数只能用于直接初始化"></a><code>explicit</code>构造函数只能用于直接初始化</h3><p>​	发生隐式转换的一种情况是当我们执行拷贝形式的初始化时，此时，我们只能使用直接初始化而不能使用<code>explicit</code>构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>; <span class="comment">// 正确：直接初始化</span></span><br><span class="line">Sales_data item2 = null_book; <span class="comment">// 错误：不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们用<code>explicit</code>关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。</p>
</blockquote>
<h3 id="为转换显式地使用构造函数"><a href="#为转换显式地使用构造函数" class="headerlink" title="为转换显式地使用构造函数"></a>为转换显式地使用构造函数</h3><p>​	尽管编译器不会将<code>explicit</code>的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>

<h3 id="标准库中含有显式构造函数的类"><a href="#标准库中含有显式构造函数的类" class="headerlink" title="标准库中含有显式构造函数的类"></a>标准库中含有显式构造函数的类</h3><p>​	我们用过一些标准库中的类含有单参数的构造函数：</p>
<ul>
<li>接受一个单参数的<code>cosnt char*</code>的<code>string</code>构造函数不是<code>explicit</code>；</li>
<li>接受一个容量参数的<code>vector</code>构造函数是<code>explicit</code>的；</li>
</ul>
<h2 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h2><p>​	聚合类使得用户能直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们称其为聚合的：</p>
<ul>
<li>所有成员都是<code>public</code>的；</li>
<li>没有定义任何构造函数；</li>
<li>没有类内初始值；</li>
<li>没有基类，也没有虚函数；</li>
</ul>
<p>​	我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。初始值顺序必须与生命的顺序一致。与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化，初始值列表的元素个数绝对不能超过类的成员数量，值得注意的是，显式初始化类的对象成员有三个明显的缺点：</p>
<ul>
<li>要求类的所有成员都是<code>public</code>的；</li>
<li>将正确初始化每个对象的每个重任都交给了类的用户；</li>
<li>添加或删除一个成员之后，所有的初始化语句都需要更新；</li>
</ul>
<h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><p>​	我们之前提到过：<code>constexpr</code>函数的参数和返回值必须是字面值类型。除了算术类型、引用和指针外，某些类也是字面值类型。和其它类不同，字面值类型的类可能含有<code>constexpr</code>函数成员。这样的成员必须符合<code>constexpr</code>函数的所有要求，它们是隐式<code>const</code>的。</p>
<p>​	数据成员都是字面值类型的聚合类，是字面值常量类。如果一个类不是聚合类，但它们符合下述要求，则它也是一个字面值常量类：</p>
<ul>
<li>数据成员都必须是字面值类型；</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数；</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数；</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象；</li>
</ul>
<h3 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a><code>constexpr</code>构造函数</h3><p>​	尽管构造函数不能是<code>const</code>的，但是字面值常量类的构造函数可以是<code>constexpr</code>函数，事实上，一个字面值常量类必须提供一个<code>constexpr</code>构造函数。</p>
<p>​	<code>constexpr</code>构造函数可以声明成<code>=default</code>的形式，否则<code>constexpr</code>构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合<code>constexpr</code>函数的要求，又符合<code>constexpr</code>函数的要求（意味着它能拥有的唯一可执行语句就是可执行语句）。</p>
<p>​	综合两点可知：<code>constexpr</code>构造函数体一般来说应该是空的，我们通过前置关键字<code>constexpr</code>就可以声明一个<code>constexpr</code>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span>: hw(b), io(b), other(b) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>constexpr</code>构造函数必须初始化所有数据成员，初始值或者使用<code>constexpr</code>构造函数，或者是一条常量表达式。<code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型。</p>
<hr>
<h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>​	有时候类需要它的一些成员与类本身直接相关，而不是与各个对象相关联。这时候我们就能用静态成员来声明。</p>
<h3 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h3><p>​	我们可以通过在成员的声明之前加上<code>static</code>使得其与类关联在一起。和其它成员一样，静态成员可以是<code>public</code>和<code>private</code>。静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<p>​	<strong>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</strong>类似的，静态成员函数也不与任何对象绑定在一起，他们不包含<code>this</code>指针。<strong>静态成员函数不能被声明成<code>const</code>，而且我们也不能在<code>static</code>函数体内使用<code>this</code>指针。</strong></p>
<h3 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h3><p>​	<strong>我们使用作用域运算符直接访问静态成员，显然静态成员不属于类的某个对象，但我们仍然可以使用类的对象、引用或者指针来访问静态成员。</strong>而成员函数不用通过作用域运算符就能直接使用静态成员。</p>
<h3 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h3><p>​	我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员时，不能重复<code>stataic</code>关键字，该关键字只能出现在类内部的声明语句。</p>
<blockquote>
<p>和类所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，<code>static</code>关键字则只出现在类内部的声明语句中。</p>
</blockquote>
<p>​	因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着他们不是由构造函数初始化的，而且一般来说，我们不能在类内部初始化静态成员。相反的，<strong>必须在类的外部定义和初始化每个静态成员，和其他对象一样，一个静态数据成员只能定义一次。</strong></p>
<p>​	类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure>

<p>​	这条语句定义了名为<code>interestRate</code>的对象，该对象是类<code>Account</code>的静态成员，其类型是<code>double</code>。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用<code>initRate</code>函数（<code>Account</code>的静态成员函数）。</p>
<blockquote>
<p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其它非内联函数的定义放在同一个文件中。</p>
</blockquote>
<h3 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h3><p>​	通常情况下，类的静态成员不应该在类的内部初始化。然而，**我们可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>**。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>; <span class="comment">// period是常量表达式</span></span><br><span class="line">    <span class="type">double</span> dailyTbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的<code>const</code>或<code>constexpr static</code>不需要分别定义。相反，如果我们将它用于值不能替换的场景，则该成员必须有一条定义语句。</p>
<blockquote>
<p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
<h3 id="静态成员能用于某些场景，而普通成员不能"><a href="#静态成员能用于某些场景，而普通成员不能" class="headerlink" title="静态成员能用于某些场景，而普通成员不能"></a>静态成员能用于某些场景，而普通成员不能</h3><p>​	如我们所见，静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常使用。静态数据成员可以是不完全类型，特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Bar mem1; <span class="comment">// 正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar mem2;        <span class="comment">// 错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/12/CppPrimer/CppPrimer-06/">https://pomelover.github.io/2025/12/12/CppPrimer/CppPrimer-06/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++ Primer</a><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/12/13/CppPrimer/CppPrimer-07/" title="第八章：IO库"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第八章：IO库</div></div></div></a><a class="pagination-related  no-desc" href="/2025/12/09/EffectiveCpp/EffectiveCpp-02/" title="(二)：构造/析构/赋值运算"><img class="cover" src="/images/EffectiveC++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">(二)：构造/析构/赋值运算</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">第十一章：关联容器</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/20/CppPrimer/CppPrimer-09/" title="第十章：泛型算法"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">第十章：泛型算法</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">第九章：顺序容器</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/13/CppPrimer/CppPrimer-07/" title="第八章：IO库"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">第八章：IO库</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/08/CppPrimer/CppPrimer-05/" title="第六章：函数"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-08</div><div class="info-item-2">第六章：函数</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/07/CppPrimer/CppPrimer-04/" title="第五章：语句"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-07</div><div class="info-item-2">第五章：语句</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">类 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1Sales-data%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">设计Sales_data类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84Sales-data%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">定义改进的Sales_data类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5this"><span class="toc-number">2.2.2.</span> <span class="toc-text">引入this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">引入const成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">类作用域和成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">在类的外部定义成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">定义一个返回this对象的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">定义类相关的非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89read%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">定义read和print函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">定义add函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">合成的默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">某些类不能依赖于合成的默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">在类的外部定义构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">拷贝、赋值和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">2.5.1.</span> <span class="toc-text">某些类不能依赖于合成的版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8class%E6%88%96struct%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用class或struct关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">3.2.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">3.2.1.</span> <span class="toc-text">友元的声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%86%8D%E6%8E%A2"><span class="toc-number">4.1.</span> <span class="toc-text">类成员再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">定义一个类型成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Screen%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">Screen类的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">令成员作为内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.4.</span> <span class="toc-text">重载成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">4.1.5.</span> <span class="toc-text">可变数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">4.1.6.</span> <span class="toc-text">类数据成员的初始值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-this%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">返回*this的成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8Econst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E-this"><span class="toc-number">4.2.1.</span> <span class="toc-text">从const成员函数返回*this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Econst%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.2.</span> <span class="toc-text">基于const的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">类类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.1.</span> <span class="toc-text">类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">4.3.2.</span> <span class="toc-text">友元再探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">4.3.3.</span> <span class="toc-text">类之间的友元关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="toc-number">4.3.4.</span> <span class="toc-text">令成员函数作为友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">4.3.5.</span> <span class="toc-text">函数重载和友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.3.6.</span> <span class="toc-text">友元声明和作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">作用域和定义在类外部的成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.2.</span> <span class="toc-text">名字查找与类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E7%B1%BB%E6%88%90%E5%91%98%E5%A3%B0%E6%98%8E%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-number">5.2.1.</span> <span class="toc-text">用于类成员声明的名字查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E8%A6%81%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">类型名要特殊处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-number">5.2.3.</span> <span class="toc-text">成员定义中的普通块作用域的名字查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%A4%96%E5%9B%B4%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">5.2.4.</span> <span class="toc-text">类作用域之后，在外围的作用域中查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%8D%E5%AD%97%E7%9A%84%E5%87%BA%E7%8E%B0%E5%A4%84%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">5.2.5.</span> <span class="toc-text">在文件中名字的出现处对其进行解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E8%B0%88"><span class="toc-number">6.</span> <span class="toc-text">构造函数再谈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8-1"><span class="toc-number">6.1.</span> <span class="toc-text">构造函数初始值列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC%E6%9C%89%E6%97%B6%E5%BF%85%E4%B8%8D%E5%8F%AF%E5%B0%91"><span class="toc-number">6.1.1.</span> <span class="toc-text">构造函数的初始值有时必不可少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">成员初始化的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.</span> <span class="toc-text">默认实参和构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">默认构造函数的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">使用默认构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.4.</span> <span class="toc-text">隐式的类类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AD%A5%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.4.1.</span> <span class="toc-text">只允许一步类类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8D%E6%98%AF%E6%80%BB%E6%9C%89%E6%95%88"><span class="toc-number">6.4.2.</span> <span class="toc-text">类类型转换不是总有效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%91%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.4.3.</span> <span class="toc-text">抑制构造函数定义的隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.4.4.</span> <span class="toc-text">explicit构造函数只能用于直接初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%BD%AC%E6%8D%A2%E6%98%BE%E5%BC%8F%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.4.5.</span> <span class="toc-text">为转换显式地使用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E5%90%AB%E6%9C%89%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="toc-number">6.4.6.</span> <span class="toc-text">标准库中含有显式构造函数的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">聚合类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">字面值常量类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.6.1.</span> <span class="toc-text">constexpr构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.</span> <span class="toc-text">类的静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.1.1.</span> <span class="toc-text">声明静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">使用类的静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.1.3.</span> <span class="toc-text">定义静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.1.4.</span> <span class="toc-text">静态成员的类内初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E8%83%BD%E7%94%A8%E4%BA%8E%E6%9F%90%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%8C%E8%80%8C%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E4%B8%8D%E8%83%BD"><span class="toc-number">7.1.5.</span> <span class="toc-text">静态成员能用于某些场景，而普通成员不能</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一章：关联容器"/></a><div class="content"><a class="title" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器">第十一章：关联容器</a><time datetime="2025-12-21T13:04:07.913Z" title="发表于 2025-12-21 21:04:07">2025-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/21/EffectiveCpp/EffectiveCpp-04/" title="(四)：设计与声明"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(四)：设计与声明"/></a><div class="content"><a class="title" href="/2025/12/21/EffectiveCpp/EffectiveCpp-04/" title="(四)：设计与声明">(四)：设计与声明</a><time datetime="2025-12-21T05:37:35.219Z" title="发表于 2025-12-21 13:37:35">2025-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/MySTL/MySTL-02-string/" title="（二）STL介绍与实现：string"><img src="/images/STL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（二）STL介绍与实现：string"/></a><div class="content"><a class="title" href="/2025/12/20/MySTL/MySTL-02-string/" title="（二）STL介绍与实现：string">（二）STL介绍与实现：string</a><time datetime="2025-12-20T13:44:34.705Z" title="发表于 2025-12-20 21:44:34">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/CppPrimer/CppPrimer-09/" title="第十章：泛型算法"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十章：泛型算法"/></a><div class="content"><a class="title" href="/2025/12/20/CppPrimer/CppPrimer-09/" title="第十章：泛型算法">第十章：泛型算法</a><time datetime="2025-12-20T05:39:18.068Z" title="发表于 2025-12-20 13:39:18">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第九章：顺序容器"/></a><div class="content"><a class="title" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器">第九章：顺序容器</a><time datetime="2025-12-15T14:24:00.955Z" title="发表于 2025-12-15 22:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>