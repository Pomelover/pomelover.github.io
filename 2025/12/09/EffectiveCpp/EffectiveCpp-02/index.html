<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>(二)：构造/析构/赋值运算 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="条款05：了解C++默默编写并调用哪些函数 Know the functions C++ silently writes and calls.  ​	什么时候空类不再是空类呢？当C++处理过它之后，如果你没有声明，编译器就会为它声明一个拷贝构造函数、一个拷贝赋值操作符和一个析构函数。 ​	因此当你写下如下类： 1class Empty &#123; &#125;;  ​	就等同于你写下了： 123">
<meta property="og:type" content="article">
<meta property="og:title" content="(二)：构造&#x2F;析构&#x2F;赋值运算">
<meta property="og:url" content="https://pomelover.github.io/2025/12/09/EffectiveCpp/EffectiveCpp-02/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="条款05：了解C++默默编写并调用哪些函数 Know the functions C++ silently writes and calls.  ​	什么时候空类不再是空类呢？当C++处理过它之后，如果你没有声明，编译器就会为它声明一个拷贝构造函数、一个拷贝赋值操作符和一个析构函数。 ​	因此当你写下如下类： 1class Empty &#123; &#125;;  ​	就等同于你写下了： 123">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/EffectiveC++.png">
<meta property="article:published_time" content="2025-12-09T14:04:39.498Z">
<meta property="article:modified_time" content="2025-12-13T17:59:07.246Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ 学习记录">
<meta property="article:tag" content="Effective C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/EffectiveC++.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(二)：构造/析构/赋值运算",
  "url": "https://pomelover.github.io/2025/12/09/EffectiveCpp/EffectiveCpp-02/",
  "image": "https://pomelover.github.io/images/EffectiveC++.png",
  "datePublished": "2025-12-09T14:04:39.498Z",
  "dateModified": "2025-12-13T17:59:07.246Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/09/EffectiveCpp/EffectiveCpp-02/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '(二)：构造/析构/赋值运算',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">(二)：构造/析构/赋值运算</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">(二)：构造/析构/赋值运算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-09T14:04:39.498Z" title="发表于 2025-12-09 22:04:39">2025-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-13T17:59:07.246Z" title="更新于 2025-12-14 01:59:07">2025-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Effective-C/">Effective C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解<code>C++</code>默默编写并调用哪些函数</h1><blockquote>
<p>Know the functions <code>C++</code> silently writes and calls.</p>
</blockquote>
<p>​	什么时候空类不再是空类呢？当<code>C++</code>处理过它之后，如果你没有声明，编译器就会为它声明一个拷贝构造函数、一个拷贝赋值操作符和一个析构函数。</p>
<p>​	因此当你写下如下类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>​	就等同于你写下了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>() &#123; ... &#125;</span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	只有当这些函数被调用时，他们才会被编译器创建出来。注意，编译器产出的析构函数是非虚的。同时，编译器创建的拷贝构造函数与拷贝赋值操作符<strong>只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象</strong>。</p>
<p>​	考虑一个<code>NamedObject</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedObject</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> T&amp; value);</span><br><span class="line">    <span class="built_in">NamedObject</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string nameValue;</span><br><span class="line">    T objectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>由于声明了一个构造函数，编译器将不再创建默认构造函数。</strong><code>NamedObject</code>既没有声明拷贝构造函数，也没有声明拷贝赋值操作符，所以编译器会创建这些函数（如果它们被调用的话）。现在，我们来看看拷贝构造函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">n1</span><span class="params">(<span class="string">&quot;small&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">n2</span><span class="params">(n1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>​	编译器生成的拷贝构造函数必须以<code>n1.nameValue</code>和<code>n1.objectValue</code>为初值设定<code>n2</code>。<code>nameValue</code>是<code>string</code>，<code>n2</code>将调用<code>string</code>的拷贝构造函数并以<code>n1</code>的作为实参；而<code>objectValue</code>是<code>int</code>，<code>n2.objectValue</code>将拷贝<code>n1</code>的每一个<code>bit</code>来完成初始化。编译器为<code>NamedObject&lt;int&gt;</code>所生成的拷贝赋值运算符与拷贝构造运算符如出一辙，但一般而言只有当生出的代码合法且有适当机会证明它有意义。万一两个条件有一个不符合，编译器会拒绝为类生成<code>operator=</code>。</p>
<p>​	例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedObject</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string&amp; nameValue;</span><br><span class="line">    <span class="type">const</span> T objectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	那么我们再考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">newDog</span><span class="params">(<span class="string">&quot;nana&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;qiqi&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">3</span>)</span></span>;</span><br><span class="line">p = s;</span><br></pre></td></tr></table></figure>

<p>​	赋值之前，不论<code>p.nameValue</code>和<code>s.nameValue</code>指向不同的<code>string</code>对象。而赋值之后呢？<code>p.nameValue</code>应该指向<code>s.nameValue</code>的那个<code>string</code>吗？当然不是对吧，<code>p.nameValue</code>是引用类型，它绑定后不能再改绑了，</p>
<p>​	因此<code>C++</code>将拒绝编译那一行赋值动作。如果你打算在一个含有引用成员的类内支持赋值操作，你必须自己定义拷贝赋值操作符，面对内含<code>const</code>成员的类，编译器反应也是一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>编译器可以自己为类创建默认构造函数、拷贝构造函数、拷贝赋值操作符和析构函数；</li>
</ol>
<hr>
<h1 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h1><blockquote>
<p>Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
<p>​	有时候你不希望你的类被拷贝，因为部分类是独一无二的。但是组织这一类代码的编译并不直观，通常如果你不希望类支持某一特定功能，只要不声明函数就行，但这个策略对默认拷贝构造函数、拷贝赋值运算符是无效的：编译器会默认创建。</p>
<p>​	如何解决呢？答案的关键是：所有编译器产出的函数都是<code>public</code>。为阻止这些函数被创建出来，你可以自行声明，将其声明为<code>private</code>。</p>
<p>​	一般而言，这做法并不安全，因为成员函数与友元函数&#x2F;友元类都能调用<code>private</code>函数。除非你够聪明，不去定义它们。<strong>将成员函数声明为<code>private</code>而且故意不实现它们</strong>是被大家接受的，因而被用在标准程序库中，实现<code>ios_base</code>&#x2F;<code>basic_ios</code>。</p>
<p>​	将链接器错误移至编译器是可能的，只要将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>就可以办到，但最好的做法是在一个专门阻止拷贝的基类中进行设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	因此当你为了阻止某个类被拷贝时，我们唯一需要做的就是继承<code>Uncopyable</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>Uncopyable</code>类的实现和运用颇为微妙，包括你不一定得以<code>public</code>继承它，以及<code>Uncopyable</code>的析构函数不一定得是<code>virtual</code>的等等。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>为驳回编译器自动提供的功能，可将相应的成员函数声明为<code>private</code>并且不予实现。</li>
</ol>
<hr>
<h1 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h1><blockquote>
<p>Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
<p>​	我们有许多方法记录时间，因此设计一个<code>TimeKeeper</code>基类与多个子类作为不同记时方法合情合理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>();</span><br><span class="line">    ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicClock</span>: <span class="keyword">public</span> TimeKeeper;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterColor</span>: <span class="keyword">public</span> TimeKeeper;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>​	种类繁多不易创建，那么我们通过工厂模式来管理创建吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	为遵守工厂函数的规矩，<code>getTimeKeeper()</code>返回的对象必须位于堆上，因此为了避免泄露内存和其他资源，将<code>factory</code>函数返回的每一个对象适当<code>delete</code>掉十分重要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeKeeper* ptk = <span class="built_in">getTimeKeeper</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>

<p>​	但是，这样是存在问题的。因为我们的<code>getTimeKeeper</code>返回的指针指向了一个派生类对象，但其却经由一个基类指针被删除，而目前的基类的析构函数是非虚的。**<code>C++</code>指出，子类对象经由父类指针被删除，而该父类带着一个非虚的析构函数，其结果是未被定义的，**事实上，实际执行时，通常会发生对象的派生部分没被销毁。</p>
<p>​	解决这个问题的办法很简单，<strong>将父类析构函数声明为虚函数</strong>。这样你的派生对象能够得到正确销毁。可以记住如下建议：<strong>任何类只要有虚函数，都请确定其有一个虚的析构函数。</strong></p>
<p>​	<strong>但是如果类不含虚函数，则通常表示它并不意图作为一个父类使用。当类不被当做父类时，令其析构函数为虚函数是坏主意。</strong></p>
<p>​	我们想实现虚函数，需要通过虚函数表与虚指针来实现。<strong>每一个带有虚函数的类都有一个相应的虚函数表，而带有虚函数的类对象将会有一个虚指针指向该虚函数表，当对象调用某一虚函数时，将会根据虚指针查询虚函数表中函数地址位置。这代表你实现虚函数将会存在额外的空间开销。</strong></p>
<p>​	有时候令类带有一个纯虚析构函数可能颇为便利。如果我们希望拥有抽象类，但没有纯虚函数，此时将析构函数声明为纯虚的能实现你的想法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMOV</span>&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AMOV</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	但是你最好为其提供一份定义。析构函数的运作方式是：<strong>最深层的类最先被析构</strong>，然后是其每一个父类的析构函数被调用。编译器在<code>AMOV</code>的派生类中将创建一个<code>~AMOV</code>的调用动作，因此你必须为函数提供一份定义。</p>
<p>​	<strong>给父类一个虚析构函数这个规则只适用于带多态性质的基类上</strong>，这种父类设计目的是为了用来通过基类接口处理派生类对象。但并非所有父类都是为了多态用途。但不用于多态用途时，你无需声明虚析构函数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol>
<li>带多态性质的父类应该声明一个虚析构函数。如果类带有任何虚函数，它就应该拥有一个虚析构函数。</li>
<li>类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明虚析构函数。</li>
</ol>
<hr>
<h1 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h1><blockquote>
<p>Prevent exceptions from leaving destuctors.</p>
</blockquote>
<p>​	<code>C++</code>并不禁止析构函数吐出异常，但它不鼓励你这样做。考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Widget&gt; v;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	当<code>v</code>被销毁时，它有责任销毁其内含的所有<code>Widgets</code>。但如果析构期间抛出异常，你仍然应该对后续元素进行析构，但如果异常过多，程序若不是结束执行就是导致不明确行为。<code>C++</code>不喜欢析构函数吐出异常。</p>
<p>​	但如果你的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	为确保客户不忘记在<code>DBConnection</code>对象上调用<code>close</code>，一个合理想法是创建以恶用来管理<code>DBConnection</code>资源的类，并在其析构函数中调用<code>close</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	只要调用<code>close</code>成功，那一切都没问题。但如果该调用导致异常，<code>DBConn</code>析构函数会传播该异常，也就是允许它离开这个析构函数，那会造成问题。</p>
<p>​	有两个方法可以避免这一问题：</p>
<ol>
<li><p>如果<code>close</code>抛出异常就结束程序；</p>
<blockquote>
<p>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去。</p>
</blockquote>
</li>
<li><p>吞下因调用<code>close</code>而发生的异常；</p>
<blockquote>
<p>一般而言，将异常吞掉是坏主意，因为它压制了“某些动作失败”的重要信息！然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。</p>
</blockquote>
</li>
</ol>
<p>​	但这两种都无法对“导致<code>close</code>抛出异常”情况作出反应。</p>
<p>​	一个较佳的策略是重新设计<code>DBConn</code>接口，使客户有机会对可能出现的问题做出反应。例如<code>DBConn</code>自己可以提供一个<code>close</code>函数，因而赋予客户一个机会得以处理“因该操作而发生的异常”。<code>DBConn</code>也可以追踪其所管理<code>DBConnection</code>是否已经被关闭，并在答案为否时由其析构函数关闭。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后不传播或结束程序；</li>
<li>如果客户需要对某个操作函数运行期间做出的异常作出反应，那么类应该提供一个普通函数执行该操作；</li>
</ol>
<hr>
<h1 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用<code>virtual</code>函数</h1><blockquote>
<p>Never call virtual functions during construction or destruction.</p>
</blockquote>
<p>​	<strong>请不要在构造函数和析构函数期间调用虚函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	现在如果执行如下操作，会发生什么事情呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p>​	首先我们会调用<code>Transaction</code>构造函数，但<code>Transaction</code>构造函数的最后一行调用了虚函数<code>logTransaction</code>，这正是问题所在，此时由于派生类成分未被构造，因此调用的是<code>Transaction</code>内的版本，不是<code>BuyTransaction</code>版本。而析构函数的调用将会从派生类开始，则父类析构时派生类已经被析构，此时调用的同样是<code>Transaction</code>内版本。因此，此时无法实现多态。</p>
<p>​	侦测“构造&#x2F;析构函数运行期间是否调用虚函数”并不总是这般轻松。有时候你的构造函数会调用其它成员函数，而这些成员函数可能会调用虚函数，此时这一错误并不容易察觉。</p>
<p>​	那该如何确保每次这种继承体系下的对象被创建，就会有适当的版本<code>logTransaction</code>被调用呢？一种做法是在将虚函数改为非虚版本，然后要求派生类构造函数传递必要信息向上传递给基类的构造函数。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ol>
<li>在构造和析构期间不要调用虚函数，因为该类调用不会下降至派生类。</li>
</ol>
<hr>
<h1 id="条款10：令operator-返回一个-this的引用"><a href="#条款10：令operator-返回一个-this的引用" class="headerlink" title="条款10：令operator=返回一个*this的引用"></a>条款10：令<code>operator=</code>返回一个<code>*this</code>的引用</h1><p>​	为了实现如<code>x=y=z=15</code>的连锁赋值，赋值运算符必须返回一个引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这个协议适用于所有赋值相关运算。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ol>
<li>令赋值操作符返回一个对<code>*this</code>的引用。</li>
</ol>
<hr>
<h1 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款11：在<code>operator=</code>中处理自我赋值</h1><p>​	自我赋值发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123; <span class="comment">/*...*/</span>&#125;;</span><br><span class="line">Widget w;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">w = w;</span><br></pre></td></tr></table></figure>

<p>​	虽然这个例子比较愚蠢，但有时候其实会潜在进行该类赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];</span><br></pre></td></tr></table></figure>

<p>​	有时候你会利用资源管理对象来实现，那此时你不需要考虑自我赋值的特殊情况，但大多数情况下，你需要考虑自我赋值带来的影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; <span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator=</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果像如上定义赋值运算符，当发生自我赋值时，<code>delete pb</code>时已经将<code>rhs.pb</code>删除，此时，自己持有了一个指向已经被删除的对象的指针！</p>
<p>​	想阻止该错误，传统做法就是在赋值运算符定义最前面进行一次判断，达到自我赋值的检验目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	但是这个版本仍然存在异常方面的麻烦，如果<code>new</code>语句出现异常，此时老指针被删除，新指针被指向了一块被删除的<code>Bitmap</code>。</p>
<p>​	令人高兴的是，让<code>operator=</code>具备异常安全性往往可以预防自我赋值带来的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="built_in">newBitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	现在如果遇到问题，则我们原来的指针也能保持原状，即使没有进行自我赋值的检查，这段代码还是能保证安全。如果你很关心效率，可以把正统测试再次放回函数起始处。但是这样做之前先请你自己考虑，自我赋值发生的频率有多高，毕竟自我赋值会使代码变大一些并导入一个控制流分支。</p>
<p>​	在赋值运算符函数内手工排列语句的一个替代方案是，使用<code>copy and swap</code>技术：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ol>
<li>确保当对象自我赋值时<code>operator=</code>有良好行为；</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同个对象时，行为仍然正确；</li>
</ol>
<hr>
<h1 id="条款12：复制对象时不要忘记每一个成分"><a href="#条款12：复制对象时不要忘记每一个成分" class="headerlink" title="条款12：复制对象时不要忘记每一个成分"></a>条款12：复制对象时不要忘记每一个成分</h1><p>​	设计良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，就是拷贝构造函数和拷贝赋值赋值符。考虑一个类用来表现顾客：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logCall</span><span class="params">(<span class="type">const</span> string funcName)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Cusomer&amp; rhs);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy assignment operator&quot;</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	但如果我们新加入一个成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这时候现有的拷贝函数执行的是局部拷贝，它们的确复制了顾客的名字，但没有复制新添加的<code>lastTransaction</code>。大多数编译器对此不会检测错误。因此，当你使用自己的构造函数，务必确认每一个成分得到复制。</p>
<p>​	一旦发生继承，可能会造成一个潜藏危机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs):<span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>PriorityCustomer</code>的拷贝函数看起来是复制了<code>PriorityCustomer</code>内的每一样东西，但是实际上，它们复制了<code>PriorityCustomer</code>声明的成员变量，但每个<code>PriorityCustomer</code>还内含了它所继承的<code>Customer</code>成员变量副本，而那些成员变量却未被赋值。<code>PriorityCustomer</code>的拷贝构造函数并没有指定实参传给其基类构造函数，因此<code>PriorityCustomer</code>对象的<code>Customer</code>成分会被不带实参的<code>Customer</code>构造函数初始化。</p>
<p>​	任何时候，<strong>只要你需要为派生类撰写拷贝函数，你都必须小心复制其父类成分</strong>，那些成分一般是私有的，你无法直接访问它，但是你应该调用相应的父类函数。</p>
<p>​	总结，当你编写一个拷贝函数，请你确保：</p>
<ol>
<li>复制所有局部成员变量；</li>
<li>调用所有基类内适当的拷贝函数；</li>
</ol>
<p>​	同时，你需要注意，请不要混合调用拷贝构造函数和拷贝赋值函数：令拷贝赋值操作符调用拷贝构造函数是不合理的，因为这就像试图构造一个已经存在的对象；反方向也是无意义的，构造函数用来初始化新对象，而赋值操作符只施加于已初始化对象。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ol>
<li>拷贝函数应该确保复制对象内所有成员变量和所有父类成分；</li>
<li>不要尝试以某个拷贝函数实现另一个拷贝函数；</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/09/EffectiveCpp/EffectiveCpp-02/">https://pomelover.github.io/2025/12/09/EffectiveCpp/EffectiveCpp-02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a><a class="post-meta__tags" href="/tags/Effective-C/">Effective C++</a></div><div class="post-share"><div class="social-share" data-image="/images/EffectiveC++.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/12/12/CppPrimer/CppPrimer-06/" title="第七章：类"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第七章：类</div></div></div></a><a class="pagination-related  no-desc" href="/2025/12/08/CppPrimer/CppPrimer-05/" title="第六章：函数"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第六章：函数</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/15/EffectiveCpp/EffectiveCpp-03/" title="(三)：资源管理"><img class="cover" src="/images/EffectiveC++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">(三)：资源管理</div></div></div></a><a class="pagination-related no-desc" href="/2025/11/11/EffectiveCpp/EffectiveCpp-01/" title="(一)：让自己习惯C++"><img class="cover" src="/images/EffectiveC++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-11</div><div class="info-item-2">(一)：让自己习惯C++</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img class="cover" src="/images/EffectiveC++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-27</div><div class="info-item-2">(五)：实现</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/21/EffectiveCpp/EffectiveCpp-04/" title="(四)：设计与声明"><img class="cover" src="/images/EffectiveC++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">(四)：设计与声明</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/05/CppPrimer/CppPrimer-02/" title="第三章：字符串、向量和数组"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-05</div><div class="info-item-2">第三章：字符串、向量和数组</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/08/CppPrimer/CppPrimer-05/" title="第六章：函数"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-08</div><div class="info-item-2">第六章：函数</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">条款05：了解C++默默编写并调用哪些函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">2.</span> <span class="toc-text">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">条款08：别让异常逃离析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">条款09：绝不在构造和析构过程中调用virtual函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-this%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">条款10：令operator&#x3D;返回一个*this的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">条款11：在operator&#x3D;中处理自我赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">7.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%B8%8D%E8%A6%81%E5%BF%98%E8%AE%B0%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">8.</span> <span class="toc-text">条款12：复制对象时不要忘记每一个成分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">8.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十五章：面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计">第十五章：面向对象程序设计</a><time datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四章：重载运算与类型转换"/></a><div class="content"><a class="title" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换">第十四章：重载运算与类型转换</a><time datetime="2025-12-28T14:40:27.817Z" title="发表于 2025-12-28 22:40:27">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(五)：实现"/></a><div class="content"><a class="title" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现">(五)：实现</a><time datetime="2025-12-27T05:12:38.578Z" title="发表于 2025-12-27 13:12:38">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十三章：拷贝控制"/></a><div class="content"><a class="title" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制">第十三章：拷贝控制</a><time datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十二章：动态内存"/></a><div class="content"><a class="title" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存">第十二章：动态内存</a><time datetime="2025-12-22T12:49:57.719Z" title="发表于 2025-12-22 20:49:57">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>