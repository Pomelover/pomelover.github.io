<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第十章：泛型算法 | Pomeloverの自习室</title><meta name="author" content="Pomelover"><meta name="copyright" content="Pomelover"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="泛型算法 简介​	标准库提供了一组算法，这些算法大多数都独立于任何特定的容器，可用于不同类型的容器和不同类型的元素。  概述​	大多数算法都定义在algorithm头文件中，标准库还在numeric中定义了一组数值泛型算法。一般情况下，这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。 ​	例如，我们有一个int的vector，我们需要在vector查找是否包含一个特定值，">
<meta property="og:type" content="article">
<meta property="og:title" content="第十章：泛型算法">
<meta property="og:url" content="https://pomelover.github.io/2025/12/20/CppPrimer/CppPrimer-09/index.html">
<meta property="og:site_name" content="Pomeloverの自习室">
<meta property="og:description" content="泛型算法 简介​	标准库提供了一组算法，这些算法大多数都独立于任何特定的容器，可用于不同类型的容器和不同类型的元素。  概述​	大多数算法都定义在algorithm头文件中，标准库还在numeric中定义了一组数值泛型算法。一般情况下，这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。 ​	例如，我们有一个int的vector，我们需要在vector查找是否包含一个特定值，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pomelover.github.io/images/cpp_logo.png">
<meta property="article:published_time" content="2025-12-20T05:39:18.068Z">
<meta property="article:modified_time" content="2025-12-21T05:36:40.932Z">
<meta property="article:author" content="Pomelover">
<meta property="article:tag" content="C++ Primer">
<meta property="article:tag" content="C++ 学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pomelover.github.io/images/cpp_logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第十章：泛型算法",
  "url": "https://pomelover.github.io/2025/12/20/CppPrimer/CppPrimer-09/",
  "image": "https://pomelover.github.io/images/cpp_logo.png",
  "datePublished": "2025-12-20T05:39:18.068Z",
  "dateModified": "2025-12-21T05:36:40.932Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pomelover",
      "url": "https://pomelover.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pomelover.github.io/2025/12/20/CppPrimer/CppPrimer-09/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第十章：泛型算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(/images/pages/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Pomeloverの自习室</span></a><a class="nav-page-title" href="/"><span class="site-name">第十章：泛型算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fab fa-weixin"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">第十章：泛型算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-20T05:39:18.068Z" title="发表于 2025-12-20 13:39:18">2025-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-21T05:36:40.932Z" title="更新于 2025-12-21 13:36:40">2025-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="泛型算法-简介"><a href="#泛型算法-简介" class="headerlink" title="泛型算法 简介"></a>泛型算法 简介</h1><p>​	标准库提供了一组算法，这些算法大多数都独立于任何特定的容器，可用于不同类型的容器和不同类型的元素。</p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​	大多数算法都定义在<code>algorithm</code>头文件中，标准库还在<code>numeric</code>中定义了一组数值泛型算法。一般情况下，这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p>​	例如，我们有一个<code>int</code>的<code>vector</code>，我们需要在<code>vector</code>查找是否包含一个特定值，可以使用标准库算法<code>find</code>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),val);</span><br></pre></td></tr></table></figure>

<p>​	<strong><code>find</code>前两个参数是表示元素范围的迭代器</strong>，第三个参数是一个值，如果搜索匹配，则返回指向第一个等于给定值的元素的迭代器；如果搜索失败，则返回第二个参数。</p>
<h2 id="算法如何工作"><a href="#算法如何工作" class="headerlink" title="算法如何工作"></a>算法如何工作</h2><p>​	在概念上，<code>find</code>应该执行如下操作：</p>
<ol>
<li>访问序列中的首元素；</li>
<li>比较此元素与我们要查找的值；</li>
<li>如果此元素与我们要查找的值匹配，则返回标识此元素的值；</li>
<li>否则，前进到下一个元素，并重复执行步骤2和3；</li>
<li>如果到达序列尾，则停止；</li>
<li>到达序列末尾，应该返回一个指出元素未找到的值；</li>
</ol>
<h2 id="迭代器令算法不依赖于容器"><a href="#迭代器令算法不依赖于容器" class="headerlink" title="迭代器令算法不依赖于容器"></a>迭代器令算法不依赖于容器</h2><p>​	可以看到上述<code>find</code>操作的只是迭代器，因此这种算法是可以兼容不同的容器。</p>
<h2 id="但算法依赖于元素类型的操作"><a href="#但算法依赖于元素类型的操作" class="headerlink" title="但算法依赖于元素类型的操作"></a>但算法依赖于元素类型的操作</h2><p>​	迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个或多个元素类型上的操作。</p>
<blockquote>
<p>关键概念：<strong>算法永远不会执行容器操作</strong></p>
<p>​	<strong>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上</strong>，执行迭代器的操作。这个特性带来了一个非常必要的编程假定：<strong>算法永远不会改变底层容器的大小！</strong></p>
<p>​	后面我们会看到，标准库定义了一类特殊的迭代器，称为插入器。与普通迭代器只能遍历所绑定的容器相比，插入器能做更多的事情。<strong>当给这类迭代器赋值时，它们会在底层容器上执行插入操作。</strong></p>
</blockquote>
<hr>
<h1 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h1><blockquote>
<p><strong>理解算法的最基本的方法就是了解它们是否读取元素、改变元素或者重排元素顺序。</strong></p>
</blockquote>
<h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><p>​	一些算法只会读取输入范围内的元素，而从不改变元素。例如：<code>find</code>&#x2F;<code>count</code>&#x2F;<code>accumulate</code>…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>accumulate</code>第三个参数类型决定了函数使用哪个加法运算符以及返回值类型。</p>
</blockquote>
<h3 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h3><p>​	<code>accumulate</code>第三个参数作为求和起点，这蕴含了一个编程假定，将元素类型加到和的类型上的操作必须是可行的。因此，如果我们想将<code>string</code>进行相加应该使用以下语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// 正确</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="string">&quot;&quot;</span>); <span class="comment">// 错误，第三个为const char*</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于只读取而不改变元素的算法，通常最好使用<code>cbegin()</code>&#x2F;<code>cend()</code>。但是如果你计划使用返回的迭代器来改变元素的值，就必须使用<code>begin()</code>&#x2F;<code>end()</code>的结果作为参数。</p>
</blockquote>
<h3 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h3><p>​	另一个只读算法是<code>equal</code>，用于确定两个序列是否保存相同的值。它将第一个序列中的元素与第二个序列的元素进行比较，如果对应元素都相等，则返回<code>true</code>，否则返回<code>false</code>。此算法接受三个迭代器，前两个和往常一样，第三个为第二个序列的首元素。而且元素类型也不必一样，只要我们能用<code>==</code>来比较两个元素类型即可。</p>
<blockquote>
<p>那些只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p>
</blockquote>
<h2 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h2><p>​	一些算法将新值赋予序列中的元素，当我们使用这类算法时，<strong>必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。</strong></p>
<h3 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h3><p>​	一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。</p>
</blockquote>
<h3 id="介绍back-inserter"><a href="#介绍back-inserter" class="headerlink" title="介绍back_inserter"></a>介绍<code>back_inserter</code></h3><p>​	一种保证算法有足够元素来容纳输出数据是使用插入迭代器。插入迭代器是一种容器中添加元素的迭代器。<strong>通常情况下，当我们使用一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</strong></p>
<p>​	现在我们使用<code>back_inserter</code>（一个定义在<code>iterator</code>的函数）。<code>back_iterator</code>接受一个容器指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_iterator</span>(vec);</span><br><span class="line">*it = <span class="number">42</span>;  <span class="comment">// vec中现在有一个元素，值为42</span></span><br></pre></td></tr></table></figure>

<p>​	我们常常使用<code>back_iterator</code>来创建一个迭代器，作为算法的目的位置来使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">0</span>); <span class="comment">// 正确 添加10个元素到容器内</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><p>​	拷贝（<code>copy</code>）算法是向另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置。<strong>此算法将输入范围中的元素拷贝到目的序列中。</strong>传递给<code>copy</code>的目的序列至少要包含与输入序列一样多的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1)/<span class="built_in">sizeof</span>(*a1)];</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1), a2); <span class="comment">// a1内容拷贝到a2</span></span><br></pre></td></tr></table></figure>

<p>​	<code>copy</code>返回的是其目的位置迭代器的值，即<code>ret</code>恰好指向拷贝到<code>a2</code>的尾元素之后的位置。</p>
<p>​	多个算法都提供了所谓的拷贝版本，这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新的序列保存这些结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">replace</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>); <span class="comment">// 将序列所有0替换为42 </span></span><br><span class="line"><span class="built_in">replace_copy</span>(list.<span class="built_in">cbegin</span>(),list.<span class="built_in">cend</span>(),<span class="built_in">back_insserter</span>(ivec),<span class="number">0</span>,<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 将序列所有0替换为42的结果保存在ivec中</span></span><br></pre></td></tr></table></figure>

<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>​	某些算法会重排容器中顺序，一个明显的例子就是<code>sort</code>。调用<code>sort</code>会重排输入序列中的元素，使之有序，它是利用元素类型的<code>&lt;</code>运算符来实现排序的。</p>
<p>​	如果想消除重复元素，可以在对<code>vector</code>排序后使用<code>unique</code>算法，使得不重复的元素出现在<code>vector</code>开始部分，再利用容器的<code>erase</code>操作删除重复元素。</p>
<blockquote>
<p>注意：标准库算法永远对迭代器操作而不是容器进行操作，因此，算法不能之间添加或删除元素。</p>
</blockquote>
<hr>
<h1 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h1><blockquote>
<p>很多算法都会比较输入序列中的元素，默认情况下，这类算法使用<code>&lt;</code>&#x2F;<code>==</code>运算符完成比较，标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。</p>
</blockquote>
<h2 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h2><p>​	例如，我们在得到了确保唯一的集合<code>vector&lt;string&gt; words</code>后，希望<code>words</code>能够按照长度排序，大小相同则按照字典序排序，我们可以使用<code>sort</code>的第二个版本，接受第三个参数，此参数我们称为谓词。</p>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>​	谓词是一个可调用的表达式，其返回结果是一个可以作为条件的值，标准库算法所使用的谓词分为两类：<strong>一元谓词和二元谓词</strong>。<strong>接受谓词参数的算法对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型。</strong></p>
<p>​	接受二元谓词参数的<code>sort</code>版本将用这个谓词来替代<code>&lt;</code>来比较元素。**<code>sort</code>使用的谓词必须在输入序列所有可能的元素值上定义一个一致的序。**</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p>​	根据算法接受一元谓词或者二元谓词，我们传递给算法的谓词必须严格接受一个或两个谓词。但是，某些时候我们希望传递给算法的谓词需要更多参数，超出了算法对谓词的限制。</p>
<p>​	例如，我们希望调用<code>find_if</code>函数来查找之前我们排好序的<code>words</code>中第一个大于等于给定长度的元素。<code>find_if</code>接受一对迭代器，同时接受第三个谓词参数。<code>find_if</code>对每个元素调用这个谓词，并判断是否返回。</p>
<p>​	但是，<code>find_if</code>接受一元谓词，我们无法向它传入第二个参数来表示长度。</p>
<h3 id="介绍lambda"><a href="#介绍lambda" class="headerlink" title="介绍lambda"></a>介绍<code>lambda</code></h3><p>​	我们可以向一个算法传递任何类别的可调用对象。对于一个对象或表达式，如果可以对其运用调用运算符，则称其为可调用的。即，如果<code>e</code>是一个可调用的表达式，则我们可以编写代码<code>e(args)</code>，其中<code>args</code>是一个逗号分割的一个或多个参数的列表。</p>
<p>​	目前为止，我们只使用过两种可调用对象：函数和函数指针。<code>lambda</code>表达式也是一个可调用对象。一个<code>lambda</code>表达式表示一个可调用的代码单元。我们可以将其理解为一个<strong>未命名的内联函数</strong>。与函数不同的是，<code>labmda</code>可能定义在函数内部，一个<code>lambda</code>表达式具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](param list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>

<p>​	其中：</p>
<ul>
<li><code>capture list</code>用来捕获函数定义的局部变量列表；</li>
<li><code>param list</code>&#x2F;<code>return type</code>&#x2F;<code>function body</code>与普通函数类似。但是，<code>lambda</code>表达式必须使用尾置返回来指定返回类型。</li>
</ul>
<p>​	我们永远要包含捕获列表和函数体，参数列表和返回类型可以忽略。如果忽略参数列表，<code>lambda</code>根据函数体中代码推断出返回类型；如果忽略返回类型，则根据函数体中的代码推断出返回类型，如果函数体只是一个<code>return</code>语句，则返回类型从返回的表达式类型推断；否则返回类型为<code>void</code>。</p>
<h3 id="向lambda传递参数"><a href="#向lambda传递参数" class="headerlink" title="向lambda传递参数"></a>向<code>lambda</code>传递参数</h3><p>​	与一个普通函数调用类似，调用一个<code>lambda</code>时给定的实参用来初始化<code>lambda</code>的形参列表，通常实参与形参类型必须匹配。与普通函数不同的是，<code>lambda</code>表达式不能有默认参数。</p>
<h3 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h3><p>​	如果我们希望捕获局部变量，那我们只需将其放入捕获列表中即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="type">const</span> string&amp; a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	捕获的变量可以在<code>lambda</code>内调用。</p>
<blockquote>
<p>一个<code>lambda</code>只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体内使用该变量。</p>
</blockquote>
<p>​	一个<code>lambda</code>可以直接使用定义在当前函数之外的名字。捕获列表只用于局部非<code>static</code>变量，<code>lambda</code>可以直接使用局部<code>static</code>变量和它所在函数之外声明的名字。</p>
<h2 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a><code>lambda</code>捕获和返回</h2><p>​	当定义了一个<code>lambda</code>时，编译器生成一个与<code>lambda</code>对应的新的类类型。默认情况下，从<code>lambda</code>生成的类都包含一个对应该<code>lambda</code>所捕获的变量的数据成员。类似任何普通类的数据成员，<code>lambda</code>的数据成员也在<code>lambda</code>对象创建时被初始化。</p>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>​	<code>lambda</code>的捕获方式也有值和引用的区别。采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是<strong>在创建时拷贝，而不是调用时拷贝。</strong></p>
<h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><p>​	我们也可以用引用方式捕获变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f2</span>(); <span class="comment">//j=0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果我们使用引用方式捕获一个变量，就必须确保被引用的对象在<code>lambda</code>执行的时候是存在的。<code>lambda</code>捕获的都是局部变量，这些变量在结束的时候就不复存在了。</p>
<p>​	引用捕获有时是必要的，特别是当你的变量不能进行拷贝的时候。我们也可以从一个函数返回<code>lambda</code>，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个<code>lambda</code>，则与函数不能返回一个局部变量的引用类似，此<code>lambda</code>也不能包含引用变量。</p>
<blockquote>
<p>当以引用方式捕获一个变量时，必须保证在<code>lambda</code>执行时变量是存在的。</p>
</blockquote>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>​	除了显式列出捕获变量之外，还可以让编译器根据<code>lambda</code>体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个<code>&amp;</code>或<code>=</code>。<code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>表示采用值捕获方式。</p>
<p>​	我们还可以混用隐式捕获和显式捕获，但此时你需要将<code>=</code>&#x2F;<code>&amp;</code>放在第一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;,c](<span class="type">const</span> string&amp;s)&#123;<span class="comment">/**/</span>&#125;);</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os](<span class="type">const</span> string&amp;s)&#123;<span class="comment">/**/</span>&#125;);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>lambda</code>捕获列表</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>空捕获列表。</td>
</tr>
<tr>
<td><code>[names]</code></td>
<td><code>names</code>是逗号分隔的名字列表，这些名字都是函数的局部变量，<strong>默认情况下，捕获列表中的变量都被拷贝，如果名字前有<code>&amp;</code>则为引用捕获。</strong></td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>隐式捕获列表，都采用引用捕获。</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>隐式捕获列表，都采用值捕获。</td>
</tr>
<tr>
<td><code>[&amp;, identifier_list]</code></td>
<td></td>
</tr>
<tr>
<td><code>[=, identifier_list]</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变<code>lambda</code></h3><p>​	默认情况下，对于一个值被拷贝的变量，<code>lambda</code>不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在<strong>参数列表首</strong>加上关键字<code>mutable</code>。因此，可变<code>lambda</code>能省略参数列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// f可以改变它所捕获的变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">// j=43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	而引用列表是否可以修改依赖于引用指向的是否是<code>const</code>类型。</p>
<h3 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定<code>lambda</code>返回类型</h3><p>​	默认情况下，如果一个<code>lambda</code>包含<code>return</code>之外的任何语句，则编译器假定此<code>lambda</code>返回<code>void</code>。当我们需要指定<code>lambda</code>的返回类型时，需要使用尾置返回类型。</p>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>​	对于那种只在一两个地方使用的简单操作，<code>lambda</code>表达式是最有用的，如果我们需要在很多地方使用相同的操作，通常应该定义一个函数。</p>
<p>​	如果<code>lambda</code>捕获列表为空，通常可以用函数来代替它。但是对于一个捕获局部变量的<code>lambda</code>来说，用函数来代替它就不是那么容易了。比如如下函数不能用在<code>find_if</code>中作为谓词：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准库bind函数"><a href="#标准库bind函数" class="headerlink" title="标准库bind函数"></a>标准库<code>bind</code>函数</h3><p>​	我们可以通过标准库函数<code>bind</code>解决该问题。它定义在<code>functional</code>头文件中，可以将<code>bind</code>函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p>
<p>​	调用<code>bind</code>的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list)</span><br></pre></td></tr></table></figure>

<p>​	其中<code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个逗号分隔的参数列表，对应给定的<code>callable</code>的参数。即，我们调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给<code>arg_list</code>中的参数。<code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数。这些参数是占位符，表示<code>newCallable</code>的参数，它们占据了传递给<code>newCallable</code>的参数的位置。<code>n</code>表示生成的可调用对象中的参数位置。</p>
<h3 id="绑定check-size的sz参数"><a href="#绑定check-size的sz参数" class="headerlink" title="绑定check_size的sz参数"></a>绑定<code>check_size</code>的<code>sz</code>参数</h3><p>​	作为一个简单的例子，我们将使用<code>bind</code>生成一个调用<code>check_size</code>的对象，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用placeholders名字"><a href="#使用placeholders名字" class="headerlink" title="使用placeholders名字"></a>使用<code>placeholders</code>名字</h3><p>​	名字<code>_n</code>都定义在一个名为<code>placeholders</code>的命名空间，而这个命名空间本身定义在<code>std</code>命名空间，为了使用这些名字，我们需要写上两个命名空间。例如：<code>using std::placeholders::_1;</code>。</p>
<h3 id="bind的参数"><a href="#bind的参数" class="headerlink" title="bind的参数"></a><code>bind</code>的参数</h3><p>​	如前文所述，我们可以用<code>bind</code>修正参数的值。更一般的，可以用<code>bind</code>绑定给定可调用对象中的参数或重新安排其顺序。例如，假定<code>f</code>是一个可调用对象，它有5个参数，则下面对<code>bind</code>的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, a, b, _2, c, _1);</span><br></pre></td></tr></table></figure>

<p>​	生成一个新的可调用对象，它有两个参数，分别用占位符<code>_2</code>&#x2F;<code>_1</code>表示。当我们调用<code>g(X,Y)</code>时，实际上我们调用的是<code>f(a,b,Y,c,X)</code>。</p>
<h3 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h3><p>​	默认情况下，<code>bind</code>的那些不是占位符的参数被拷贝到<code>bind</code>返回的可调用对象中。但是与<code>lambda</code>类似，有时我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。为了绑定引用参数，我们需要利用标准库中的<code>ref</code>函数，函数<code>ref</code>返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个<code>cref</code>函数，生成一个保存<code>const</code>引用的类。</p>
<hr>
<h1 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h1><p>​	之前提到过，除了普通迭代器外，标准库在<code>iterator</code>中还定义了额外几种迭代器：</p>
<ul>
<li><strong>插入迭代器</strong>：这些迭代器被绑定到一个容器上，可用来向容器插入元素；</li>
<li><strong>流迭代器</strong>：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的<code>IO</code>流；</li>
<li><strong>反向迭代器</strong>：这些迭代器向后而不是向前移动，除了<code>forward_list</code>之外的标准库容器都有反向迭代器；</li>
<li><strong>移动迭代器</strong>：这些专用的迭代器不是拷贝其中元素，而是移动它们；</li>
</ul>
<h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><p>​	插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>
<table>
<thead>
<tr>
<th>插入迭代器操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>it=t</code></td>
<td>在<code>it</code>指定的当前位置插入值<code>t</code>。假定<code>c</code>是<code>it</code>绑定的容器，依赖于插入迭代器的不同种类，会分别调用<code>push_back</code>&#x2F;<code>push_front</code>&#x2F;<code>insert</code>。</td>
</tr>
<tr>
<td><code>*it</code>&#x2F;<code>++it</code>&#x2F;<code>it++</code></td>
<td>这些操作虽然存在，但不会对<code>it</code>做任何事情，每个操作都返回<code>it</code>。</td>
</tr>
</tbody></table>
<p>​	插入器有三种类型：</p>
<ul>
<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器；</li>
<li><code>front_inserter</code>：创建一个使用<code>push_front</code>的迭代器；</li>
<li><code>inserter</code>：创建一个使用<code>insert</code>的迭代器，此函数接受第二个参数，这个参数必须是一个只想给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<p>​	理解插入器的工作过程很重要，当我们使用<code>inserter(c, iter)</code>时，我们得到一个迭代器，使用它将会把元素插入到<code>iter</code>原来所指向的元素之前的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">// 与下面方式等价</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it, val);</span><br><span class="line">++it;</span><br></pre></td></tr></table></figure>

<p>​	<code>front_inserter</code>生成的迭代器的行为与<code>inserter</code>生成的迭代器完全不一样。当我们使用<code>front_inserter</code>时，元素总是插入到容器第一个元素之前。即使我们传递给<code>inserter</code>传递给<code>inserter</code>的位置原来指向第一个元素，只要我们在次元素之前插入一个新元素，此元素就不再是容器的首元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2,lst3;</span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(),lst.<span class="built_in">cend</span>(),<span class="built_in">front_inserter</span>(lst2)); <span class="comment">// lst2 = 4,3,2,1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(),lst.<span class="built_in">cend</span>(),<span class="built_in">inserter</span>(lst3,lst<span class="number">3.</span><span class="built_in">begin</span>())); <span class="comment">// lst3 = 1,2,3,4</span></span><br></pre></td></tr></table></figure>

<h2 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a><code>iostream</code>迭代器</h2><p>​	虽然<code>iostream</code>类型不是容器，但标准库定义了可以用于这些<code>IO</code>类型对象的迭代器。<code>istream_iterator</code>读取输入流，<code>ostream_iterator</code>向一个输出流写数据。</p>
<h3 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a><code>istream_iterator</code>操作</h3><p>​	当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流，因此<code>istream_iterator</code>要读取的类型必须定义了输入运算符。当创建一个<code>istream_iterator</code>时，我们将其绑定到一个流，当然我们还可以默认初始化迭代器，这样就可以创建一个可以当作尾后值使用的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>; <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; int_eof;     <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_in</span><span class="params">(in)</span></span>; <span class="comment">// 从&quot;afile&quot;读取字符串</span></span><br></pre></td></tr></table></figure>

<p>​	下面是一个使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;</span><br><span class="line"><span class="keyword">while</span>(in_iter!=eof)</span><br><span class="line">&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们还可以重写为如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>,eof</span>; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>istream_iterator</code>操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>istream_iterator&lt;T&gt; in(is)</code></td>
<td><code>in</code>从输入流<code>is</code>读取类型为<code>T</code>的值</td>
</tr>
<tr>
<td><code>istream_iterator&lt;T&gt; end</code></td>
<td>读取类型为<code>T</code>的值的<code>istream_iterator</code>迭代器，表示尾后位置</td>
</tr>
<tr>
<td><code>in1==in2</code>&#x2F;<code>in1!=in2</code></td>
<td><code>in1</code>和<code>in2</code>必须读取相同类型，如果都是尾后迭代器或者绑定到相同的输入则两者相同。</td>
</tr>
<tr>
<td><code>*in</code></td>
<td>返回从流中读取的值</td>
</tr>
<tr>
<td><code>in-&gt;mem</code></td>
<td>与<code>(*in).mem</code>含义相同</td>
</tr>
<tr>
<td><code>++in</code>&#x2F;<code>in++</code></td>
<td>使用元素类型所定义的<code>&gt;&gt;</code>从输入流中读取下一个值</td>
</tr>
</tbody></table>
<h3 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h3><p>​	我们可以使用某些算法来操作流迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line">cout&lt;&lt; <span class="built_in">accumulate</span>(in, eof, <span class="number">0</span>)&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="istream-iterator允许使用懒惰求值"><a href="#istream-iterator允许使用懒惰求值" class="headerlink" title="istream_iterator允许使用懒惰求值"></a><code>istream_iterator</code>允许使用懒惰求值</h3><p>​	当我们将一个<code>istream_iterator</code>绑定到一个流，标准库并不保证迭代器立即从流读取数据。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。</p>
<h3 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a><code>ostream_iterator</code>操作</h3><p>​	我们可以对任何具有输出运算符（<code>&lt;&lt;</code>运算符）的类型定义<code>ostream_iterator</code>。当创建一个<code>ostream_iterator</code>，我们可以提供第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个<code>C</code>风格字符串。必须将<code>ostream_iterator</code>绑定到一个指定的流，不允许空的或表示尾后位置的<code>ostream_iterator</code>。</p>
<table>
<thead>
<tr>
<th><code>ostream_iterator</code>操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ostream_iterator&lt;T&gt; out(os)</code></td>
<td><code>out</code>将类型为<code>T</code>写到输出流<code>os</code>中。</td>
</tr>
<tr>
<td><code>ostream_iterator&lt;T&gt; out(os, d)</code></td>
<td><code>out</code>将类型为<code>T</code>的值写到输出流<code>os</code>中，每个值后面都会输出一个<code>d</code>。</td>
</tr>
<tr>
<td><code>out = val</code></td>
<td>用<code>&lt;&lt;</code>运算符将<code>val</code>写入到<code>out</code>所绑定的<code>ostream</code>中，<code>val</code>的类型必须与<code>out</code>可写的类型兼容。</td>
</tr>
<tr>
<td><code>*out</code>&#x2F;<code>++out</code>&#x2F;<code>out++</code></td>
<td>不对<code>out</code>做任何事情，每个运算符都返回<code>out</code>。</td>
</tr>
</tbody></table>
<p>​	一个例子可以看到<code>ostream_iterator</code>的好用之处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h3><p>​	我们可以为任何定义了<code>&gt;&gt;</code>运算符的类型创建<code>istream_iterator</code>对象，为任何定义了<code>&lt;&lt;</code>的类型创建<code>ostream_iterator</code>。</p>
<h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>​	<strong>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增以及递减操作的含义会颠倒过来。</strong>除了<code>forward_list</code>外，其它容器都支持反向迭代器。我们可以通过<code>rbegin</code>&#x2F;<code>rend</code>和<code>crbegin</code>&#x2F;<code>crend</code>成员函数来获得反向迭代器。</p>
<h3 id="反向迭代器需要递减运算符"><a href="#反向迭代器需要递减运算符" class="headerlink" title="反向迭代器需要递减运算符"></a>反向迭代器需要递减运算符</h3><p>​	<strong>我们只能在既支持<code>++</code>也支持<code>--</code>的迭代器来定义反向迭代器。</strong>因此，我们不能在<code>forward_list</code>和流迭代器创建反向迭代器。</p>
<h3 id="反向迭代器和其它迭代器间的关系"><a href="#反向迭代器和其它迭代器间的关系" class="headerlink" title="反向迭代器和其它迭代器间的关系"></a>反向迭代器和其它迭代器间的关系</h3><p>​	<strong>反向迭代器用来表示反向遍历的元素范围，而这种范围的位置与普通迭代器的范围天然不对称</strong>，因此反向迭代器与对应普通迭代器之间必须存在一个元素偏移；<strong>结果是，从普通迭代器构造反向迭代器或通过 <code>base()</code> 转回普通迭代器时，这两个迭代器并不指向同一个元素，这是为了确保反向区间和正向区间在逻辑上保持一致。</strong></p>
<hr>
<h1 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h1><p>​	<strong>任何算法的最基本特性是它要求其迭代器提供了哪些操作</strong>。算法所要求的迭代器操作可以分为5个迭代器类别：</p>
<table>
<thead>
<tr>
<th>迭代器类别</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>只读，不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写，不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody></table>
<h2 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h2><p>​	类似容器，迭代器也提供了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。<strong>除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。</strong><code>C++</code>标准指明了泛型和数值算法的每个迭代器参数的最小类别。</p>
<blockquote>
<p>对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。</p>
</blockquote>
<h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><ol>
<li><p><strong>输入迭代器</strong>：可以读取序列中的元素，一个输入迭代器必须支持：</p>
<ul>
<li>用于比较两个迭代器的相等和不相等运算符；</li>
<li>用于推进迭代器的前置和后置递增运算；</li>
<li>用于读取元素的解引用运算符，<strong>解引用只会出现在赋值运算符的右侧；</strong></li>
<li>箭头运算符，即解引用迭代器，提取对象的成员；</li>
<li>输入迭代器只用于顺序访问，对于一个输入迭代器，<code>*it++</code>保证是有效的，但递增它可能导致所有其它指向流的迭代器失效。其结果就是，<strong>不能保证输入迭代器的状态可以保存下来并用来访问元素</strong>。输入迭代器只能用于单遍扫描算法。</li>
</ul>
</li>
<li><p><strong>输出迭代器</strong>：可以看作输入迭代器功能上的补集，只写而不读元素，其必须支持：</p>
<ul>
<li>用于推进迭代器的前置和后置递增运算；</li>
<li>解引用运算符，<strong>只出现在赋值运算符的左侧；</strong></li>
<li>我们只能向一个输出迭代器赋值一次。类似输入迭代器，<strong>输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。</strong></li>
</ul>
</li>
<li><p><strong>前向迭代器</strong>：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。</p>
</li>
<li><p><strong>双向迭代器</strong>：可以正向&#x2F;反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置的递减运算符。算法<code>reverse</code>要求双向迭代器，除了<code>forward_list</code>之外，其它标准库都提供双向迭代器要求的迭代器。</p>
</li>
<li><p><strong>随机访问迭代器</strong>：提供在常量时间内访问序列中任意元素的能力。还支持如下操作</p>
<ul>
<li>用于比较两个迭代器相对位置的关系运算符；</li>
<li>迭代器和一个整数值的加减运算（<code>+</code>&#x2F;<code>+=</code>&#x2F;<code>-</code>&#x2F;<code>-=</code>），计算结果是迭代器在序列中前进或后退给定整数个元素后的位置；</li>
<li>用于两个迭代器上的减法运算符，得到两个迭代器的距离；</li>
<li>下标运算符，与<code>*(iter[n])</code>等价；</li>
</ul>
</li>
</ol>
<h2 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h2><p>​	在任何算法分类之上，还有一组参数规范，理解这些参数规范对学习新算法很有帮助。大多数算法具有如下形式之一：</p>
<ol>
<li><code>alg(beg,end,other args)</code></li>
<li><code>alg(beg,end,dest,other args)</code></li>
<li><code>alg(beg,end,beg2,other args)</code></li>
<li><code>alg(beg,end,beg2,end2,other args)</code></li>
</ol>
<h3 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h3><p>​	<code>dest</code>参数是一个表示算法可以写入的目的位置的迭代器，算法假定，按其需要写入数据，不管写入多少个元素都是安全的。</p>
<blockquote>
<p><strong>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。</strong></p>
</blockquote>
<p>​	如果<code>dest</code>是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，<code>dest</code>被绑定到一个插入迭代器或是一个<code>ostream_iterator</code>。</p>
<h3 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h3><p>​	接受单独的<code>beg2</code>或者是接受<code>beg2</code>&#x2F;<code>end2</code>的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。只接受单独<code>beg2</code>的假定从<code>beg2</code>开始的范围与<code>beg</code>&#x2F;<code>end</code>表示的范围至少一样大。</p>
<h2 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h2><p>​	除了参数规范，<strong>算法还遵循一套命名和重载规范。</strong>这些规范处理诸如：如何提供一个操作代替<code>&lt;</code>或<code>==</code>运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h3 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h3><p>​	接受谓词参数来代替<code>&lt;</code>或<code>==</code>运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替<code>&lt;</code>或<code>==</code>。</p>
<h3 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a><code>_if</code>版本的算法</h3><p>​	接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);</span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred);</span><br></pre></td></tr></table></figure>

<p>​	这两个算法都在输入范围中查找特定元素第一次出现的位置，而<code>find</code>查找一个特定的值，<code>find_if</code>查找使得<code>pred</code>返回非零值的元素。</p>
<h3 id="区分拷贝元素的版本和不拷贝元素的版本"><a href="#区分拷贝元素的版本和不拷贝元素的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝元素的版本"></a>区分拷贝元素的版本和不拷贝元素的版本</h3><p>​	<strong>默认情况下，重排元素的算法将重拍后的元素写回到给定输入序列中，这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);</span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h1><p>​	与其它容器不同，链表类型（<code>list</code>&#x2F;<code>forward_list</code>）定义了几个成员函数形式的算法。特别是，它们定义了独有的<code>sort</code>&#x2F;<code>merge</code>&#x2F;<code>remove</code>&#x2F;<code>reverse</code>&#x2F;<code>unique</code>。通用版本的<code>sort</code>要求随机访问迭代器。因此不能用于<code>list</code>和<code>forward_list</code>，因为这两个类型分别提供双向迭代器和前向迭代器。</p>
<blockquote>
<p>对于<code>list</code>和<code>forward_list</code>，应该优先使用成员函数版本的算法而不是通用算法。</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>list</code>&#x2F;<code>forward_list</code>成员函数版本的算法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>list.merge(lst2)</code>&#x2F;<code>list.merge(lst2, comp)</code></td>
<td>将来自<code>lst2</code>中的元素合并入<code>lst</code>。<code>lst2</code>&#x2F;<code>lst</code>都必须是有序的。元素将从<code>lst2</code>中删除，在合并之后，<code>lst2</code>变为空。</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>中元素顺序</td>
</tr>
<tr>
<td><code>lst.remove(val)</code>&#x2F;<code>lst.remove_if(pred)</code></td>
<td>调用<code>erase</code>删除元素</td>
</tr>
<tr>
<td><code>lst.sort()</code>&#x2F;<code>lst.sort(comp)</code></td>
<td>比较操作排序元素</td>
</tr>
<tr>
<td><code>lst.unique()</code>&#x2F;<code>lst.unique(pred)</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝</td>
</tr>
</tbody></table>
<h2 id="splice成员"><a href="#splice成员" class="headerlink" title="splice成员"></a><code>splice</code>成员</h2><p>​	链表类型还定义了<code>splice</code>算法。</p>
<table>
<thead>
<tr>
<th><code>splice</code>成员函数的参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.splice(p,lst2)</code>&#x2F;<code>flst.splice_after(p,lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>的所有元素移动到<code>lst</code>中<code>p</code>元素之前的位置或是<code>flst</code>中之后的位置。将元素从<code>lst2</code>中删除，<code>lst2</code>的类型必须与<code>lst</code>或<code>flst</code>相同，且不能是同一个链表。</td>
</tr>
<tr>
<td><code>lst.splice(p,lst2,p2)</code>&#x2F;<code>flst.splice_after(p,lst2,p2)</code></td>
<td><code>p2</code> 是一个指向 <code>lst2</code> 中位置的有效的迭代器。将 <code>p2</code> 指向的元素移动到 <code>lst1</code> 中，或将 <code>p2</code> 之后的元素移动到 <code>lst1</code> 中。<code>lst2</code> 可以是与 <code>lst1</code> 或 <code>lst1st</code> 相同的链表。</td>
</tr>
<tr>
<td><code>lst.splice(p,lst2,b,e)</code>&#x2F;<code>flst.splice_after(p,lst2,b,e)</code></td>
<td><code>b</code> 和 <code>e</code> 必须表示 <code>lst2</code> 中的合法范围。将给定范围中的元素从 <code>lst2</code> 移动到 <code>lst1</code> 或 <code>lst1st</code>。<code>lst2</code> 与 <code>lst</code>（或 <code>f1st</code>）可以是相同的链表，但 <code>p</code> 不能指向给定范围中的元素。</td>
</tr>
</tbody></table>
<h3 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h3><p>​	多数链表特有的算法都与其通用版本很相似，但不完全相同。<strong>链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层容器。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pomelover.github.io">Pomelover</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pomelover.github.io/2025/12/20/CppPrimer/CppPrimer-09/">https://pomelover.github.io/2025/12/20/CppPrimer/CppPrimer-09/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pomelover.github.io" target="_blank">Pomeloverの自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++ Primer</a><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">C++ 学习记录</a></div><div class="post-share"><div class="social-share" data-image="/images/cpp_logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/12/20/MySTL/MySTL-02-string/" title="（二）STL介绍与实现：string"><img class="cover" src="/images/STL.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">（二）STL介绍与实现：string</div></div></div></a><a class="pagination-related  no-desc" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器"><img class="cover" src="/images/cpp_logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第九章：顺序容器</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">第十五章：面向对象程序设计</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-28</div><div class="info-item-2">第十四章：重载运算与类型转换</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-26</div><div class="info-item-2">第十三章：拷贝控制</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">第十二章：动态内存</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/21/CppPrimer/CppPrimer-10/" title="第十一章：关联容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">第十一章：关联容器</div></div></div></a><a class="pagination-related no-desc" href="/2025/12/15/CppPrimer/CppPrimer-08/" title="第九章：顺序容器"><img class="cover" src="/images/cpp_logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">第九章：顺序容器</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/jinx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pomelover</div><div class="author-info-description">Stay Humble, Keep Learning.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pomelover"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pomelover" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Hope this helps you.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">泛型算法 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">算法如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A4%E7%AE%97%E6%B3%95%E4%B8%8D%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">迭代器令算法不依赖于容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E7%AE%97%E6%B3%95%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">但算法依赖于元素类型的操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">初始泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">只读算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">算法和元素类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">操作两个序列的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">写容器元素的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8D%E6%A3%80%E6%9F%A5%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">算法不检查写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8Dback-inserter"><span class="toc-number">3.2.2.</span> <span class="toc-text">介绍back_inserter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">拷贝算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">重排容器元素的算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">定制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">向算法传递函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">4.1.1.</span> <span class="toc-text">谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8Dlambda"><span class="toc-number">4.1.3.</span> <span class="toc-text">介绍lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91lambda%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.4.</span> <span class="toc-text">向lambda传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.5.</span> <span class="toc-text">使用捕获列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">4.2.</span> <span class="toc-text">lambda捕获和返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%8D%95%E8%8E%B7"><span class="toc-number">4.2.1.</span> <span class="toc-text">值捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7"><span class="toc-number">4.2.2.</span> <span class="toc-text">引用捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="toc-number">4.2.3.</span> <span class="toc-text">隐式捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98lambda"><span class="toc-number">4.2.4.</span> <span class="toc-text">可变lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Alambda%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.5.</span> <span class="toc-text">指定lambda返回类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">4.3.</span> <span class="toc-text">参数绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93bind%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">标准库bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9Acheck-size%E7%9A%84sz%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">绑定check_size的sz参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8placeholders%E5%90%8D%E5%AD%97"><span class="toc-number">4.3.3.</span> <span class="toc-text">使用placeholders名字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">bind的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.5.</span> <span class="toc-text">绑定引用参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">再探迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">插入迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">iostream迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#istream-iterator%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.1.</span> <span class="toc-text">istream_iterator操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E6%93%8D%E4%BD%9C%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">使用算法操作流迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#istream-iterator%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%E6%87%92%E6%83%B0%E6%B1%82%E5%80%BC"><span class="toc-number">5.2.3.</span> <span class="toc-text">istream_iterator允许使用懒惰求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ostream-iterator%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.4.</span> <span class="toc-text">ostream_iterator操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%84%E7%90%86%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.5.</span> <span class="toc-text">使用流迭代器处理类类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">反向迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%9C%80%E8%A6%81%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.1.</span> <span class="toc-text">反向迭代器需要递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%85%B6%E5%AE%83%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.2.</span> <span class="toc-text">反向迭代器和其它迭代器间的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">泛型算法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">五类迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">6.1.1.</span> <span class="toc-text">迭代器类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">算法形参模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E5%8D%95%E4%B8%AA%E7%9B%AE%E6%A0%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">接受单个目标迭代器的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">接受第二个输入序列的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">6.3.</span> <span class="toc-text">算法命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E8%B0%93%E8%AF%8D"><span class="toc-number">6.3.1.</span> <span class="toc-text">一些算法使用重载形式传递一个谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E7%89%88%E6%9C%AC%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">_if版本的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%8B%B7%E8%B4%9D%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%88%E6%9C%AC%E5%92%8C%E4%B8%8D%E6%8B%B7%E8%B4%9D%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">6.3.3.</span> <span class="toc-text">区分拷贝元素的版本和不拷贝元素的版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">特定容器算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#splice%E6%88%90%E5%91%98"><span class="toc-number">7.1.</span> <span class="toc-text">splice成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%89%B9%E6%9C%89%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">链表特有的操作会改变容器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十五章：面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/12/30/CppPrimer/CppPrimer-14/" title="第十五章：面向对象程序设计">第十五章：面向对象程序设计</a><time datetime="2025-12-30T13:54:00.507Z" title="发表于 2025-12-30 21:54:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四章：重载运算与类型转换"/></a><div class="content"><a class="title" href="/2025/12/28/CppPrimer/CppPrimer-13/" title="第十四章：重载运算与类型转换">第十四章：重载运算与类型转换</a><time datetime="2025-12-28T14:40:27.817Z" title="发表于 2025-12-28 22:40:27">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现"><img src="/images/EffectiveC++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(五)：实现"/></a><div class="content"><a class="title" href="/2025/12/27/EffectiveCpp/EffectiveCpp-05/" title="(五)：实现">(五)：实现</a><time datetime="2025-12-27T05:12:38.578Z" title="发表于 2025-12-27 13:12:38">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十三章：拷贝控制"/></a><div class="content"><a class="title" href="/2025/12/26/CppPrimer/CppPrimer-12/" title="第十三章：拷贝控制">第十三章：拷贝控制</a><time datetime="2025-12-26T14:17:58.722Z" title="发表于 2025-12-26 22:17:58">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存"><img src="/images/cpp_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十二章：动态内存"/></a><div class="content"><a class="title" href="/2025/12/22/CppPrimer/CppPrimer-11/" title="第十二章：动态内存">第十二章：动态内存</a><time datetime="2025-12-22T12:49:57.719Z" title="发表于 2025-12-22 20:49:57">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Pomelover</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>